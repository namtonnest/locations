<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width,initial-scale=1">
        <title>Location Locations — Home</title>
        <style>
            body{font-family:Inter,system-ui,Arial;margin:0;background:#0f1724;color:#fff;display:flex;align-items:center;justify-content:center;height:100vh}
            .card{background:#fff;color:#0f1724;padding:28px;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.4);max-width:680px;text-align:center}
            .brand{font-weight:800;font-size:20px;color:#ff6a00;margin-bottom:8px}
            .lead{color:#374151;margin:8px 0 18px}
            .btn{background:#ff6a00;color:#fff;padding:10px 16px;border-radius:8px;border:none;cursor:pointer;font-weight:700}
            .secondary{margin-left:12px;background:#e6eef6;color:#0f1724}
            a{color:inherit;text-decoration:none}
        </style>
    </head>
    <body>
        <div class="card">
            <div class="brand">Location — Map Editor</div>
            <div class="lead">Welcome — open the map editor to place models, draw shapes, and share map state.</div>
            <div>
                <a href="/map.html"><button class="btn">Open Map Editor</button></a>
                <a href="https://github.com/namtonnest/locations" target="_blank" rel="noopener"><button class="btn secondary">View Source</button></a>
            </div>
            <p style="font-size:13px;color:#6b7280;margin-top:14px">Tip: Drawings and labels are saved to the backend when you use Share.</p>
        </div>
    </body>
</html>
                try { if (renderer.setClearColor) renderer.setClearColor(0xffffff, 1); } catch (e) {}
                // paint 2D canvas white as an additional safety (some browsers composite differently)
                try { const ctx2d = canvas.getContext('2d'); if (ctx2d) { ctx2d.fillStyle = '#ffffff'; ctx2d.fillRect(0,0,canvas.width,canvas.height); } } catch(e) {}
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(45, canvas.width / canvas.height, 0.1, 1000);
                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(10,10,10); scene.add(light);
                const ambient = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambient);
                loader.load(url, (gltf) => {
                    const obj = gltf.scene || gltf.scenes[0];
                    // normalize and position
                    const box = new THREE.Box3().setFromObject(obj);
                    const size = box.getSize(new THREE.Vector3());
                    const center = box.getCenter(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    obj.position.x -= center.x; obj.position.y -= center.y; obj.position.z -= center.z;
                    scene.add(obj);
                    camera.position.set(0, maxDim * 0.7, maxDim * 1.8);
                    camera.lookAt(new THREE.Vector3(0,0,0));
                    renderer.render(scene, camera);
                    // Composite onto a white 2D canvas to avoid transparent/black backgrounds
                    try {
                        const out = document.createElement('canvas');
                        out.width = canvas.width; out.height = canvas.height;
                        const outCtx = out.getContext('2d');
                        if (outCtx) {
                            outCtx.fillStyle = '#ffffff';
                            outCtx.fillRect(0, 0, out.width, out.height);
                            outCtx.drawImage(canvas, 0, 0);
                            const dataUrl = out.toDataURL('image/png');
                            thumbCache[url] = dataUrl;
                            saveThumbCache();
                            // cleanup
                            renderer.dispose();
                            try { scene.remove(obj); } catch (e) {}
                            resolve(dataUrl);
                            return;
                        }
                    } catch (err) {
                        console.warn('Composite canvas failed, falling back to raw canvas', err);
                    }
                    // fallback if composite failed
                    const dataUrl = canvas.toDataURL('image/png');
                    thumbCache[url] = dataUrl;
                    saveThumbCache();
                    renderer.dispose();
                    try { scene.remove(obj); } catch (e) {}
                    resolve(dataUrl);
                }, undefined, (err) => {
                    resolve(fallbackThumb(id || 'Model'));
                });
                // safety timeout: if loader doesn't respond in 6s, return fallback
                setTimeout(() => { if (!thumbCache[url]) resolve(fallbackThumb(id || 'Model')); }, 6000);
            } catch (e) { resolve(fallbackThumb(id || 'Model')); }
        });
    }

    function renderLibrary() {
        libraryList.innerHTML = '';
        modelLibrary.forEach(item => {
            const row = document.createElement('div');
            row.className = 'lib-item';
            const info = document.createElement('div');
            info.style.flex = '1';
            // thumbnail
            const thumbImg = document.createElement('img');
            thumbImg.className = 'thumb';
            thumbImg.alt = item.name || 'model';
            // if cached thumb available, show it; otherwise start generation and use fallback
            if (thumbCache[item.url]) {
                thumbImg.src = thumbCache[item.url];
            } else {
                thumbImg.src = fallbackThumb(item.name || 'Model');
                // async generate and update when ready
                generateThumbnail(item.url, item.name).then(dataUrl => { thumbImg.src = dataUrl; });
            }
            const title = document.createElement('div');
            title.textContent = item.name || 'Model';
            info.appendChild(title);
            const actions = document.createElement('div');
            const selectBtn = document.createElement('button');
            selectBtn.textContent = 'Use';
            selectBtn.addEventListener('click', () => {
                if (item.type === '3dtext') {
                    // prompt for text and enable text placement mode
                    const txt = prompt('Enter text to place');
                    if (!txt) return;
                    placingText = { text: txt };
                    placingModel = true; addBtn.setAttribute('aria-pressed', 'true'); addBtn.textContent = 'Cancel';
                    note.textContent = 'Click on map to place 3D text';
                    note.style.display = 'block';
                    libraryPanel.style.display = 'none';
                    return;
                }
                modelUrl = item.url;
                // if this library item defines a defaultScale, apply it for the next placement
                modelScaleOverride = item.defaultScale || 1;
                // open placement mode for convenience
                placingModel = true; addBtn.setAttribute('aria-pressed', 'true'); addBtn.textContent = 'Cancel';
                note.style.display = 'block';
                libraryPanel.style.display = 'none';
            });
            const removeBtn = document.createElement('button');
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => {
                modelLibrary = modelLibrary.filter(i => i.id !== item.id);
                saveLibrary(modelLibrary);
                renderLibrary();
            });
            actions.appendChild(selectBtn);
            actions.appendChild(removeBtn);
            row.appendChild(thumbImg);
            row.appendChild(info);
            row.appendChild(actions);
            libraryList.appendChild(row);
        });
    }

    openLibraryBtn.addEventListener('click', () => {
        const showing = libraryPanel.style.display === 'block';
        libraryPanel.style.display = showing ? 'none' : 'block';
        if (!showing) renderLibrary();
    });

    closeLibraryBtn.addEventListener('click', () => { libraryPanel.style.display = 'none'; });

    addModelToLibBtn.addEventListener('click', () => {
        const url = (addModelUrlInput.value || '').trim();
        if (!url) return alert('Paste a GLB URL');
        const id = 'm_' + Date.now();
        modelLibrary.unshift({ id, name: url.split('/').pop(), url });
        saveLibrary(modelLibrary);
        addModelUrlInput.value = '';
        renderLibrary();
    });


    let placingModel = false;
    let modelUrl = defaultModelUrl;
    // drawing state for user-drawn features
    let drawing = false;
    let currentDraw = null; // Feature being drawn (LineString)
    let drawnFeatures = []; // array of GeoJSON Features
    // multiplier to apply to computed mercator scale when placing a model
    let modelScaleOverride = 1;
    // state for placing 3D text: { text: '...' } when awaiting a click
    let placingText = null;

    addBtn.addEventListener('click', () => {
        placingModel = !placingModel;
        addBtn.setAttribute('aria-pressed', String(placingModel));
        addBtn.textContent = placingModel ? 'Cancel' : 'Add model';
        note.style.display = placingModel ? 'block' : 'none';
    });

    // Helper to create and place 3D text into the three.js scene.
    // Usage: add3DText('Hello', [lng, lat], { size: 2, height: 0.4, color: 0xff6a00 })
    async function add3DText(text, lngLat, options = {}) {
        if (!modelLayerRef || !modelLayerRef.scene) {
            alert('3D layer not ready');
            return null;
        }
        const opt = Object.assign({ size: 1.5, height: 0.3, color: 0xff6a00, fontUrl: 'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json' }, options);
        return new Promise((resolve, reject) => {
            try {
                const loader = new THREE.FontLoader();
                loader.load(opt.fontUrl, (font) => {
                    // Create geometry with a unit size and center it. The custom layer
                    // render loop will apply the mercator-based transform so the mesh
                    // itself should remain at the origin.
                    const geom = new THREE.TextGeometry(text, { font, size: 1, height: opt.height, curveSegments: 8 });
                    geom.computeBoundingBox();
                    geom.center();
                    const mat = new THREE.MeshBasicMaterial({ color: opt.color });
                    const mesh = new THREE.Mesh(geom, mat);
                    // compute mercator reference and scale multiplier
                    const mc = mapboxgl.MercatorCoordinate.fromLngLat(lngLat, 0);
                    const mcScale = mc.meterInMercatorCoordinateUnits();
                    // create transform that the 3D layer's render() will apply
                    const id = 'text_' + Date.now();
                    const transform = {
                        translateX: mc.x,
                        translateY: mc.y,
                        translateZ: mc.z,
                        rotateX: Math.PI / 2,
                        rotateY: 0,
                        rotateZ: 0,
                        scale: mcScale * (opt.size || 1)
                    };
                    // mark this entry as a 3D text model so it can be serialized/restored
                    const entry = { id, name: text, text: text, type: '3dtext', transform: Object.assign({}, transform), original: Object.assign({}, transform), meterScale: mcScale, object: mesh, url: null, geo: { lng: lngLat[0], lat: lngLat[1], alt: 0 } };
                    // keep the mesh at origin; the layer render will position it via transform
                    mesh.position.set(0, 0, 0);
                    mesh.scale.set(1, 1, 1);
                    placedModels.push(entry);
                    modelLayerRef.scene.add(mesh);
                    renderSidebar();
                    if (map) map.triggerRepaint();
                    resolve(entry.id);
                }, undefined, (err) => { console.warn('Font load failed', err); reject(err); });
            } catch (e) { reject(e); }
        });
    }

    // UX: allow Shift+click on map when placingModel is active to create 3D text via prompt
    map.on('click', async (e) => {
        if (!placingModel) return; // handled elsewhere for models
        if (!e.originalEvent) return; // safety
        const isShift = e.originalEvent.shiftKey;
        if (!isShift) return; // normal model placement handled elsewhere
        const txt = prompt('Enter text for 3D label');
        if (!txt) return;
        const coords = [e.lngLat.lng, e.lngLat.lat];
        try {
            await add3DText(txt, coords, { size: 1.5, height: 0.2, color: 0xff6a00 });
            alert('3D text added');
        } catch (err) {
            console.warn('Failed to add 3D text', err);
            alert('Failed to add 3D text');
        }
    });

    // helper to toggle overlays so they don't block map clicks during placement
    function setOverlayBlocking(block) {
        // block=true => overlays accept pointer events (normal)
        // block=false => overlays ignore pointer events so map can receive clicks
        // keep the control buttons clickable (addBtn, modelsBtn)
        try {
            sidebar.style.pointerEvents = block ? 'auto' : 'none';
            controls.style.pointerEvents = block ? 'auto' : 'none';
            note.style.pointerEvents = block ? 'auto' : 'none';
        } catch (e) { /* ignore */ }
        // ensure the Add and Models buttons remain clickable
        addBtn.style.pointerEvents = 'auto';
        const mb = document.getElementById('open-models-btn');
        if (mb) mb.style.pointerEvents = 'auto';
        // cursor on the map
        if (map && map.getCanvas()) map.getCanvas().style.cursor = block ? '' : 'crosshair';
    }

    // wire overlay toggling into the add button behavior
    (function patchAddBtn() {
        const orig = addBtn.onclick;
        // also listen for changes to placingModel
        addBtn.addEventListener('click', () => {
            setOverlayBlocking(!placingModel); // when placingModel true, we disable overlays
        });
    })();

        // --- control panel for manipulating the model after placement ---
        const controls = document.createElement('div');
        controls.id = 'model-controls';
        controls.innerHTML = `
                <div style="font-weight:600;margin-bottom:6px;">Model controls</div>
                <label style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">Rotate (deg):
                    <button id="rot-dec" type="button" class="btn secondary" style="padding:4px 8px;min-width:36px">◀</button>
                    <input id="rot" type="number" value="0" step="1" style="width:88px;padding:6px;border-radius:6px;border:1px solid rgba(2,6,23,0.06)">
                    <button id="rot-inc" type="button" class="btn secondary" style="padding:4px 8px;min-width:36px">▶</button>
                    <span style="font-size:12px;color:var(--muted);margin-left:6px">Step:</span>
                    <input id="rotStep" type="number" value="15" step="1" style="width:64px;padding:6px;border-radius:6px;border:1px solid rgba(2,6,23,0.06)">
                </label>
                <label>Scale: <input id="scale" type="number" step="0.1" value="1"></label>
                <div style="margin-top:8px;font-size:12px">Nudge (meters): <input id="nudgeStep" type="number" value="1" style="width:60px"> </div>
                <div style="margin-top:6px">
                    <button id="nudgeN">N</button>
                    <button id="nudgeW">W</button>
                    <button id="nudgeE">E</button>
                    <button id="nudgeS">S</button>
                </div>
                <div style="margin-top:8px">
                    <button id="resetModel">Reset</button>
                    <button id="removeModel" style="margin-left:8px;background:#fee2e2;border:1px solid #fecaca;color:#7f1d1d;border-radius:6px;padding:6px 8px;">Remove</button>
                </div>
                <div style="margin-top:8px">
                    <label style="font-size:13px">Altitude (m): <input id="altitude" type="number" value="0" style="width:80px;margin-left:8px"></label>
                    <label style="font-size:13px;margin-left:8px">Step: <input id="altStep" type="number" value="1" style="width:60px;margin-left:6px"></label>
                    <button id="altUp" style="margin-left:8px">Up</button>
                    <button id="altDown" style="margin-left:4px">Down</button>
                </div>
                <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
                    <button id="animateBtn" type="button" class="btn secondary" style="padding:6px 10px">Toggle animate</button>
                    <label style="font-size:13px;display:flex;align-items:center;gap:6px">Speed:
                        <input id="spinSpeed" type="number" value="0.2" step="0.005" style="width:86px;padding:6px;border-radius:6px;border:1px solid rgba(2,6,23,0.06)">
                    </label>
                </div>
        `;
        document.body.appendChild(controls);

    // add a toggle button to show/hide controls on small screens
    const controlsToggle = document.createElement('button');
    controlsToggle.id = 'controls-toggle-btn';
    controlsToggle.className = 'btn secondary';
    controlsToggle.textContent = 'Controls';
    controlsToggle.style.display = 'none';
    // place the toggle inside the left topbar column so it sits under the brand and buttons
    const leftColumn = document.querySelector('.controls-left > div') || document.querySelector('.controls-left') || document.body;
    // remove absolute positioning so it participates in the layout
    controlsToggle.style.position = 'static';
    controlsToggle.style.right = '';
    controlsToggle.style.top = '';
    controlsToggle.style.marginTop = '6px';
    leftColumn.appendChild(controlsToggle);

    // style menu (hamburger) population and wiring
    try {
        const styles = [
            { id: 'streets', url: 'mapbox://styles/mapbox/streets-v11', label: 'Streets' },
            { id: 'light', url: 'mapbox://styles/mapbox/light-v10', label: 'Light' },
            { id: 'outdoors', url: 'mapbox://styles/mapbox/outdoors-v11', label: 'Outdoors' },
            { id: 'satellite', url: 'mapbox://styles/mapbox/satellite-streets-v11', label: 'Satellite' }
        ];
        const menu = document.getElementById('style-menu');
        styles.forEach(s => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.textContent = s.label;
            btn.dataset.styleUrl = s.url;
            btn.addEventListener('click', () => {
                try { map.setStyle(s.url); } catch (e) { console.warn('Failed to set style', e); }
                // hide menu after selection
                menu.classList.add('hidden');
            });
            menu.appendChild(btn);
        });

        const ham = document.getElementById('style-hamburger');
        if (ham) {
            ham.addEventListener('click', () => {
                const menu = document.getElementById('style-menu');
                if (!menu) return;
                const isHidden = menu.classList.contains('hidden');
                if (isHidden) menu.classList.remove('hidden'); else menu.classList.add('hidden');
            });
        }
    } catch (e) { console.warn('Style menu init failed', e); }

        // wire toggle behavior
        controlsToggle.addEventListener('click', () => {
            const showing = controls.style.display === 'block';
            controls.style.display = showing ? 'none' : 'block';
            controlsToggle.textContent = showing ? 'Controls' : 'Close';
            // when controls are open, make sure overlays accept pointer events
            setOverlayBlocking(!showing);
        });

        // show toggle if on mobile-sized viewport
        function refreshControlsToggleVisibility() {
            const isMobile = window.matchMedia && window.matchMedia('(max-width:640px)').matches;
            controlsToggle.style.display = isMobile ? 'block' : 'none';
            // do not auto-open the controls panel on load; user can open it explicitly
            if (!isMobile) controls.style.display = 'none';
        }
        window.addEventListener('resize', refreshControlsToggleVisibility);
        refreshControlsToggleVisibility();

        // Desktop controls button (visible only on non-mobile) - wire to same toggle logic
        const desktopControlsBtn = document.getElementById('desktop-controls-btn');
        function refreshDesktopControlsVisibility() {
            const isMobile = window.matchMedia && window.matchMedia('(max-width:640px)').matches;
            if (desktopControlsBtn) desktopControlsBtn.style.display = isMobile ? 'none' : 'block';
        }
        if (desktopControlsBtn) {
            desktopControlsBtn.addEventListener('click', () => {
                const showing = controls.style.display === 'block';
                controls.style.display = showing ? 'none' : 'block';
                // when controls are open, ensure overlays accept pointer events
                setOverlayBlocking(!showing);
                desktopControlsBtn.textContent = showing ? 'Controls' : 'Close';
            });
        }
        window.addEventListener('resize', refreshDesktopControlsVisibility);
        refreshDesktopControlsVisibility();

    // --- Simple drawing tools (polyline) ---
    const DRAW_KEY = 'map_drawn_v1';
    function saveDraws() {
    // Intentionally no-op: drawings are not persisted locally by default.
    // Drawings will be included in the shared server state when the user clicks Share.
    return;
    }
    function loadDraws() {
    // Local loading disabled: start with no drawings. Shared drawings will be restored
    // via restoreSavedState(parsed) when loading a shared state from the server.
    return [];
    }
    // compact draw launcher + panel (saves space)
    const drawLauncher = document.createElement('button');
    drawLauncher.id = 'draw-launcher';
    drawLauncher.className = 'btn';
    drawLauncher.textContent = 'Draw';
    // place the launcher inside the same controls column as the Controls toggle
    // so it visually stacks under the Controls button and shares the same CSS
    try {
        // leftColumn is defined earlier where the controls toggle is appended
        if (typeof leftColumn !== 'undefined' && leftColumn) {
            drawLauncher.style.position = 'static';
            drawLauncher.style.marginTop = '6px';
            leftColumn.appendChild(drawLauncher);
        } else {
            // fallback: append to body
            drawLauncher.style.position = 'absolute';
            drawLauncher.style.left = '12px';
            drawLauncher.style.top = '120px';
            drawLauncher.style.zIndex = '50';
            document.body.appendChild(drawLauncher);
        }
    } catch (e) { document.body.appendChild(drawLauncher); }

    // hidden panel with draw controls and color palette
    const drawPanel = document.createElement('div');
    drawPanel.id = 'draw-panel';
    // panel will be positioned dynamically beneath the controls column when opened
    drawPanel.style.position = 'absolute';
    drawPanel.style.zIndex = '60';
    drawPanel.style.width = '220px';
    drawPanel.style.padding = '10px';
    drawPanel.style.background = '#fff';
    drawPanel.style.border = '1px solid rgba(0,0,0,0.08)';
    drawPanel.style.borderRadius = '8px';
    drawPanel.style.boxShadow = '0 6px 18px rgba(14,20,36,0.12)';
    drawPanel.style.display = 'none';
    drawPanel.innerHTML = `
        <div style="font-weight:600;margin-bottom:8px">Draw tools</div>
        <div style="display:flex;gap:8px;margin-bottom:8px">
            <button id="draw-toggle" class="btn">Draw</button>
            <button id="draw-finish" class="btn secondary">Finish</button>
        </div>
        <div style="display:flex;gap:8px;margin-bottom:8px">
            <button id="draw-clear" class="btn secondary">Clear</button>
            <button id="draw-save" class="btn">Save</button>
        </div>
        <button id="draw-refresh" class="btn" style="background:#f59e0b;color:white;border-radius:6px;padding:6px 12px;font-size:13px;margin-bottom:6px;width:100%">Refresh Draw Models</button>
        <div style="margin-top:6px;font-size:13px;font-weight:600">Color</div>
        <div id="draw-colors" style="display:flex;gap:8px;margin-top:6px"></div>
        <div style="margin-top:10px;font-size:13px;font-weight:600">Label</div>
        <div style="display:flex;gap:8px;margin-top:6px;align-items:center">
            <input id="draw-label-input" placeholder="Label text" style="flex:1;padding:6px;border-radius:6px;border:1px solid rgba(0,0,0,0.08)" />
            <button id="draw-place-label" class="btn">Place</button>
        </div>
        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
            <label style="font-size:13px;min-width:44px">Size</label>
            <input id="draw-text-size" type="number" min="8" max="48" value="12" style="width:70px;padding:6px;border-radius:6px;border:1px solid rgba(0,0,0,0.08)" />
            <input id="draw-text-size-range" type="range" min="8" max="48" value="12" style="flex:1" />
        </div>
    `;
    document.body.appendChild(drawPanel);

    const drawToggle = drawPanel.querySelector('#draw-toggle');
    const drawFinish = drawPanel.querySelector('#draw-finish');
    const drawClear = drawPanel.querySelector('#draw-clear');
    const drawSave = drawPanel.querySelector('#draw-save');
    const drawColors = drawPanel.querySelector('#draw-colors');
    const drawLabelInput = drawPanel.querySelector('#draw-label-input');
    const drawPlaceLabelBtn = drawPanel.querySelector('#draw-place-label');
    const drawTextSizeInput = drawPanel.querySelector('#draw-text-size');
    const drawTextSizeRange = drawPanel.querySelector('#draw-text-size-range');
    const drawRefreshBtn = drawPanel.querySelector('#draw-refresh');
    if (drawRefreshBtn) drawRefreshBtn.addEventListener('click', () => {
        try {
            ensureDrawSourceAndLayers();
            if (map.getSource && map.getSource('draw-source')) map.getSource('draw-source').setData({ type: 'FeatureCollection', features: drawnFeatures });
            refreshDrawSource();
            if (map && map.triggerRepaint) map.triggerRepaint();
            nudgeDrawLayers();
        } catch (e) { alert('Failed to refresh draw models: ' + e); }
    });
    let selectedTextSize = Number((drawTextSizeInput && drawTextSizeInput.value) || 12);

    // available colors
    const PALETTE = ['#ff6a00','#1f8ef1','#16a34a','#ef4444','#8b5cf6','#f59e0b'];
    let selectedDrawColor = PALETTE[0];
    // render palette
    PALETTE.forEach(c => {
        const b = document.createElement('button');
        b.type = 'button';
        b.style.width = '28px'; b.style.height = '28px'; b.style.borderRadius = '6px'; b.style.border = '2px solid transparent';
        b.style.background = c;
        b.title = c;
        if (c === selectedDrawColor) b.style.borderColor = '#111827';
        b.addEventListener('click', () => {
            selectedDrawColor = c;
            // highlight
            drawColors.querySelectorAll('button').forEach(x => x.style.borderColor = 'transparent');
            b.style.borderColor = '#111827';
        });
        drawColors.appendChild(b);
    });

    function ensureDrawSourceAndLayers() {
        try {
            // ensure style is loaded first; if not, wait for the next style.load event
            try {
                if (typeof map.isStyleLoaded === 'function' && !map.isStyleLoaded()) {
                    map.once('style.load', ensureDrawSourceAndLayers);
                    return;
                }
            } catch (e) { /* ignore */ }

            const hasSource = map.getSource && map.getSource('draw-source');
            if (!hasSource) {
                map.addSource('draw-source', { type: 'geojson', data: { type: 'FeatureCollection', features: drawnFeatures } });
            } else {
                map.getSource('draw-source').setData({ type: 'FeatureCollection', features: drawnFeatures });
            }
            if (!map.getLayer('draw-lines')) {
                // only render LineString features with the line layer
                map.addLayer({ id: 'draw-lines', type: 'line', source: 'draw-source', paint: { 'line-color': ['coalesce', ['get', 'color'], '#ff6a00'], 'line-width': 4 }, filter: ['==', '$type', 'LineString'] });
            }
            if (!map.getLayer('draw-points')) {
                map.addLayer({ id: 'draw-points', type: 'circle', source: 'draw-source', paint: { 'circle-radius': 6, 'circle-color': ['coalesce', ['get', 'color'], '#ff6a00'] }, filter: ['==', '$type', 'Point'] });
            }
            // polygon fills (interiors)
            if (!map.getLayer('draw-fills')) {
                map.addLayer({ id: 'draw-fills', type: 'fill', source: 'draw-source', paint: { 'fill-color': ['coalesce', ['get', 'color'], '#ff6a00'], 'fill-opacity': 0.18 }, filter: ['==', '$type', 'Polygon'] });
            }
            // polygon outlines
            if (!map.getLayer('draw-polygon-outlines')) {
                map.addLayer({ id: 'draw-polygon-outlines', type: 'line', source: 'draw-source', paint: { 'line-color': ['coalesce', ['get', 'color'], '#ff6a00'], 'line-width': 2 }, filter: ['==', '$type', 'Polygon'] });
            }
            if (!map.getLayer('draw-labels')) {
                // symbol layer to render point labels (use properties.text and properties.color)
                map.addLayer({
                    id: 'draw-labels',
                    type: 'symbol',
                    source: 'draw-source',
                    layout: {
                        'text-field': ['coalesce', ['get', 'text'], ''],
                        // prefer per-feature size (properties.size), fallback to the currently selectedTextSize
                        'text-size': ['coalesce', ['get', 'size'], Number(selectedTextSize) || 12],
                        'text-offset': [0, -1.2],
                        'text-anchor': 'bottom'
                    },
                    paint: {
                        // use a larger white halo so the text appears to have a background box
                        'text-color': ['coalesce', ['get', 'color'], '#ff6a00'],
                        'text-halo-color': '#ffffff',
                        'text-halo-width': 6,
                        'text-halo-blur': 0.75
                    },
                    filter: ['all', ['==', '$type', 'Point'], ['has', 'text']]
                });
            }
        } catch (e) { console.warn('ensureDrawSourceAndLayers error', e); }
    }

    function refreshDrawSource() {
        try {
            ensureDrawSourceAndLayers();
            if (map.getSource && map.getSource('draw-source')) map.getSource('draw-source').setData({ type: 'FeatureCollection', features: drawnFeatures });
        } catch (e) {}
    }

    // Force a quick visibility toggle on draw layers to nudge Mapbox to re-render them.
    function nudgeDrawLayers() {
        try {
            const ids = ['draw-labels','draw-fills','draw-lines','draw-polygon-outlines','draw-points'];
            ids.forEach(id => {
                try {
                    if (map && map.getLayer && map.getLayer(id)) {
                        try { map.setLayoutProperty(id, 'visibility', 'none'); } catch (e) {}
                        setTimeout(() => { try { map.setLayoutProperty(id, 'visibility', 'visible'); } catch (e) {} }, 80);
                    }
                } catch (e) {}
            });
        } catch (e) { }
    }

    // wire toolbar buttons
    // launcher toggles the panel
    drawLauncher.addEventListener('click', () => {
        // compute left/top so the panel appears beneath the controls column / draw button
        try {
            const parent = (typeof leftColumn !== 'undefined' && leftColumn) ? leftColumn : drawLauncher.parentElement || document.body;
            const rect = parent.getBoundingClientRect();
            // position the panel left aligned with the parent and just below it
            drawPanel.style.left = Math.max(8, rect.left + window.scrollX) + 'px';
            drawPanel.style.top = Math.max(8, rect.bottom + window.scrollY + 6) + 'px';
            // ensure panel width fits within viewport
            const maxW = Math.min(320, window.innerWidth - 24);
            drawPanel.style.width = Math.min(220, maxW) + 'px';
        } catch (e) {}
        const showing = drawPanel.style.display === 'block';
        drawPanel.style.display = showing ? 'none' : 'block';
    });

    // toggle between drawing mode and polygon mode by holding Alt (or use click to toggle polygon mode)
    let polygonMode = false; // false = LineString, true = Polygon
    drawToggle.addEventListener('click', (ev) => {
        // Shift+click toggles polygon mode
        if (ev && ev.shiftKey) {
            polygonMode = !polygonMode;
            drawToggle.textContent = polygonMode ? 'Polygon' : 'Draw';
            return;
        }
        // short click toggles drawing; Shift+click toggles polygon mode
        drawing = !drawing;
        drawToggle.textContent = drawing ? (polygonMode ? 'Drawing polygon...' : 'Drawing...') : (polygonMode ? 'Polygon' : 'Draw');
        if (drawing) {
            currentDraw = { type: 'Feature', geometry: { type: polygonMode ? 'Polygon' : 'LineString', coordinates: polygonMode ? [[]] : [] }, properties: { color: selectedDrawColor } };
            // disable map interactions while drawing so clicks place points
            try { if (map.dragPan) map.dragPan.disable(); } catch (e) {}
            try { if (map.scrollZoom) map.scrollZoom.disable(); } catch (e) {}
            try { if (map.doubleClickZoom) map.doubleClickZoom.disable(); } catch (e) {}
            try { if (map.touchZoomRotate) map.touchZoomRotate.disable(); } catch (e) {}
            try { if (map.boxZoom) map.boxZoom.disable(); } catch (e) {}
            try { const c = map.getCanvas && map.getCanvas(); if (c) c.style.cursor = 'crosshair'; } catch (e) {}
    } else {
            currentDraw = null;
            // re-enable interactions
            try { if (map.dragPan) map.dragPan.enable(); } catch (e) {}
            try { if (map.scrollZoom) map.scrollZoom.enable(); } catch (e) {}
            try { if (map.doubleClickZoom) map.doubleClickZoom.enable(); } catch (e) {}
            try { if (map.touchZoomRotate) map.touchZoomRotate.enable(); } catch (e) {}
            try { if (map.boxZoom) map.boxZoom.enable(); } catch (e) {}
            try { const c = map.getCanvas && map.getCanvas(); if (c) c.style.cursor = ''; } catch (e) {}
        }
    ensureDrawSourceAndLayers();
    });
    // labeling state: when true, the next map click will place a point feature with properties.text
    let placingLabel = false;
    drawPlaceLabelBtn.addEventListener('click', () => {
        const txt = (drawLabelInput && drawLabelInput.value || '').trim();
        if (!txt) { alert('Enter label text first'); return; }
        placingLabel = !placingLabel;
        drawPlaceLabelBtn.textContent = placingLabel ? 'Cancel' : 'Place';
        // when entering label mode, ensure overlays are not blocking the map
        setOverlayBlocking(!placingLabel);
    });

    // text size controls: sync number and range inputs and apply to existing layer if present
    function applyTextSizeToLayer(size) {
        try {
            if (map && map.getLayer && map.getLayer('draw-labels')) {
                // use an expression so per-feature `properties.size` is honored, falling back to the provided size
                const expr = ['coalesce', ['get', 'size'], Number(size) || 12];
                map.setLayoutProperty('draw-labels', 'text-size', expr);
            }
        } catch (e) { /* ignore */ }
    }
    if (drawTextSizeInput) drawTextSizeInput.addEventListener('input', (e) => {
        selectedTextSize = Number(e.target.value) || 12;
        if (drawTextSizeRange) drawTextSizeRange.value = selectedTextSize;
        applyTextSizeToLayer(selectedTextSize);
    });
    if (drawTextSizeRange) drawTextSizeRange.addEventListener('input', (e) => {
        selectedTextSize = Number(e.target.value) || 12;
        if (drawTextSizeInput) drawTextSizeInput.value = selectedTextSize;
        applyTextSizeToLayer(selectedTextSize);
    });
    drawFinish.addEventListener('click', () => {
        if (!currentDraw || !currentDraw.geometry) return;
        // for Polygon mode, ensure ring is closed and coordinates exist
        if (currentDraw.geometry.type === 'Polygon') {
            const rings = currentDraw.geometry.coordinates;
            if (!rings || !rings.length || !rings[0].length) return;
            const ring = rings[0];
            // close the ring
            if (ring.length >= 3) {
                const first = ring[0];
                const last = ring[ring.length - 1];
                if (first[0] !== last[0] || first[1] !== last[1]) ring.push(first.slice());
            } else {
                return; // not enough points for polygon
            }
        } else {
            if (!currentDraw.geometry.coordinates || !currentDraw.geometry.coordinates.length) return;
        }
        // ensure color property on finished feature
        currentDraw.properties = currentDraw.properties || {};
        currentDraw.properties.color = currentDraw.properties.color || selectedDrawColor;
        drawnFeatures.push(currentDraw);
        currentDraw = null;
        drawing = false;
        drawToggle.textContent = 'Draw';
        // re-enable interactions
        try { if (map.dragPan) map.dragPan.enable(); } catch (e) {}
        try { if (map.scrollZoom) map.scrollZoom.enable(); } catch (e) {}
        try { if (map.doubleClickZoom) map.doubleClickZoom.enable(); } catch (e) {}
        try { if (map.touchZoomRotate) map.touchZoomRotate.enable(); } catch (e) {}
        try { if (map.boxZoom) map.boxZoom.enable(); } catch (e) {}
        try { const c = map.getCanvas && map.getCanvas(); if (c) c.style.cursor = ''; } catch (e) {}
        refreshDrawSource();
        saveDraws();
    });
    drawClear.addEventListener('click', () => {
        drawnFeatures = [];
        currentDraw = null;
        drawing = false;
        drawToggle.textContent = 'Draw';
        // re-enable interactions
        try { if (map.dragPan) map.dragPan.enable(); } catch (e) {}
        try { if (map.scrollZoom) map.scrollZoom.enable(); } catch (e) {}
        try { if (map.doubleClickZoom) map.doubleClickZoom.enable(); } catch (e) {}
        try { if (map.touchZoomRotate) map.touchZoomRotate.enable(); } catch (e) {}
        try { if (map.boxZoom) map.boxZoom.enable(); } catch (e) {}
        try { const c = map.getCanvas && map.getCanvas(); if (c) c.style.cursor = ''; } catch (e) {}
        refreshDrawSource();
        saveDraws();
    });
    drawSave.addEventListener('click', () => {
        saveDraws();
        alert('Drawn features saved locally');
    });

    // restore saved draws on init
    drawnFeatures = loadDraws();
    // ensure layers present now and after style changes
    ensureDrawSourceAndLayers();
    map.on('style.load', () => { try { ensureDrawSourceAndLayers(); } catch (e) {} });
    // control elements
    const rot = document.getElementById('rot');
    const rotInc = document.getElementById('rot-inc');
    const rotDec = document.getElementById('rot-dec');
    const rotStepInput = document.getElementById('rotStep');
    const scaleInput = document.getElementById('scale');
    const nudgeStep = document.getElementById('nudgeStep');
    const nudgeN = document.getElementById('nudgeN');
    const nudgeS = document.getElementById('nudgeS');
    const nudgeE = document.getElementById('nudgeE');
    const nudgeW = document.getElementById('nudgeW');
    const resetModelBtn = document.getElementById('resetModel');
    const removeModelBtn = document.getElementById('removeModel');
    const altitudeInput = document.getElementById('altitude');
    const altStepInput = document.getElementById('altStep');
    const altUpBtn = document.getElementById('altUp');
    const altDownBtn = document.getElementById('altDown');

    // disabled until a model is placed
    function setControlsDisabled(disabled) {
        [rot, rotInc, rotDec, rotStepInput, scaleInput, nudgeStep, nudgeN, nudgeS, nudgeE, nudgeW, resetModelBtn, removeModelBtn, altitudeInput, altStepInput, altUpBtn, altDownBtn].forEach(el => { if (el) el.disabled = disabled; });
    }
    setControlsDisabled(true);

    // helpers
    const degToRad = (d) => (d * Math.PI) / 180;

    function applyTransformsFromInputs() {
        if (!selectedModelId) return;
        const entry = placedModels.find(p => p.id === selectedModelId);
        if (!entry) return;
        // Only allow yaw (Y) rotation from the UI. Keep X/Z rotations at their stored values.
        entry.transform.rotateY = degToRad(Number(rot.value || 0));
        // scaleInput is a multiplier on the stored meterScale
        if (entry.meterScale) {
            entry.transform.scale = entry.meterScale * Number(scaleInput.value || 1);
        }
    // update geographic coords shown in the sidebar
    updateEntryGeo(entry);
    renderSidebar();
    if (map) map.triggerRepaint();
    }
    // debounce helper so rapid input changes (mobile) don't trigger excessive map repaints
    function debounce(fn, wait) {
        let t = null;
        return function (...args) {
            if (t) clearTimeout(t);
            t = setTimeout(() => { t = null; fn.apply(this, args); }, wait);
        };
    }

    const debouncedApply = debounce(applyTransformsFromInputs, 120);
    if (rot) rot.addEventListener('input', debouncedApply);

    // step buttons to change yaw by rotStep degrees for easier mobile use
    if (rotInc) rotInc.addEventListener('click', () => {
        const step = Number(rotStepInput && rotStepInput.value) || 15;
        rot.value = Number(rot.value || 0) + step;
        applyTransformsFromInputs();
    });
    if (rotDec) rotDec.addEventListener('click', () => {
        const step = Number(rotStepInput && rotStepInput.value) || 15;
        rot.value = Number(rot.value || 0) - step;
        applyTransformsFromInputs();
    });
    scaleInput.addEventListener('input', applyTransformsFromInputs);

    // animate button wiring (toggle animation state on selected model)
    const animateBtn = document.getElementById('animateBtn');
    if (animateBtn) {
        animateBtn.addEventListener('click', () => {
            if (!selectedModelId) return alert('Select a model first');
            const entry = placedModels.find(p => p.id === selectedModelId);
            if (!entry) return;
            entry.animated = !entry.animated;
            renderSidebar();
            if (map) map.triggerRepaint();
        });
    }

    // spin speed input wiring
    const spinSpeedInput = document.getElementById('spinSpeed');
    if (spinSpeedInput) {
        spinSpeedInput.addEventListener('change', () => {
            if (!selectedModelId) return alert('Select a model first');
            const entry = placedModels.find(p => p.id === selectedModelId);
            if (!entry) return;
            const v = Number(spinSpeedInput.value) || 0.2;
            entry.spinSpeed = v;
            renderSidebar();
            if (map) map.triggerRepaint();
        });
    }

    function nudge(direction) {
        if (!selectedModelId) return;
        const entry = placedModels.find(p => p.id === selectedModelId);
        if (!entry || !entry.meterScale) return;
        const stepMeters = Number(nudgeStep.value) || 1;
        const delta = stepMeters * entry.meterScale; // convert meters to mercator units
        switch (direction) {
            case 'N':
                entry.transform.translateY += delta; break;
            case 'S':
                entry.transform.translateY -= delta; break;
            case 'E':
                entry.transform.translateX += delta; break;
            case 'W':
                entry.transform.translateX -= delta; break;
        }
    // update geographic coords shown in the sidebar
    updateEntryGeo(entry);
    renderSidebar();
    if (map) map.triggerRepaint();
    }

    nudgeN.addEventListener('click', () => nudge('N'));
    nudgeS.addEventListener('click', () => nudge('S'));
    nudgeE.addEventListener('click', () => nudge('E'));
    nudgeW.addEventListener('click', () => nudge('W'));

    resetModelBtn.addEventListener('click', () => {
        if (!selectedModelId) return;
        const entry = placedModels.find(p => p.id === selectedModelId);
        if (!entry || !entry.original) return;
        // restore original transform
        entry.transform.translateX = entry.original.translateX;
        entry.transform.translateY = entry.original.translateY;
        entry.transform.translateZ = entry.original.translateZ;
    // preserve original X/Z rotations, but restore yaw (Y) from original
    entry.transform.rotateY = entry.original.rotateY;
        if (entry.meterScale) entry.transform.scale = entry.meterScale;
        // update UI
    if (rot) rot.value = Math.round((entry.transform.rotateY * 180 / Math.PI) * 100) / 100;
        scaleInput.value = 1;
        // update coords/rotation shown in sidebar
        updateEntryGeo(entry);
        renderSidebar();
        if (map) map.triggerRepaint();
    });

    // remove selected model
    if (removeModelBtn) {
        removeModelBtn.addEventListener('click', () => {
            if (!selectedModelId) return;
            removeModel(selectedModelId);
        });
    }

    // altitude helpers
    function changeAltitudeByMeters(deltaMeters) {
        if (!selectedModelId) return;
        const entry = placedModels.find(p => p.id === selectedModelId);
        if (!entry) return;
        // need meter->mercator conversion using entry.meterScale (mercator units per meter)
        const scale = entry.meterScale || 1;
        const deltaMerc = deltaMeters * scale;
        entry.transform.translateZ = (entry.transform.translateZ || 0) + deltaMerc;
        // update geo.alt (store altitude in meters)
        entry.geo = entry.geo || { lng: 0, lat: 0, alt: 0 };
        entry.geo.alt = (entry.geo.alt || 0) + deltaMeters;
        // reflect in the altitude input
        if (altitudeInput) altitudeInput.value = Math.round(entry.geo.alt * 100) / 100;
        renderSidebar();
        if (map) map.triggerRepaint();
    }

    if (altUpBtn) altUpBtn.addEventListener('click', () => {
        const step = Number(altStepInput && altStepInput.value) || 1;
        changeAltitudeByMeters(step);
    });
    if (altDownBtn) altDownBtn.addEventListener('click', () => {
        const step = Number(altStepInput && altStepInput.value) || 1;
        changeAltitudeByMeters(-step);
    });

    if (altitudeInput) {
        altitudeInput.addEventListener('change', () => {
            if (!selectedModelId) return;
            const entry = placedModels.find(p => p.id === selectedModelId);
            if (!entry) return;
            const newAlt = Number(altitudeInput.value) || 0;
            const currentAlt = (entry.geo && entry.geo.alt) ? entry.geo.alt : 0;
            const delta = newAlt - currentAlt;
            changeAltitudeByMeters(delta);
        });
    }

    // --- Serialize placed models ---
    function serializePlacedModels() {
        return placedModels.map(p => {
            // For 3D text entries, serialize the text and type instead of url
            if (p.type === '3dtext') {
                return {
                    id: p.id,
                    type: '3dtext',
                    text: p.text || p.name,
                    name: p.name,
                    transform: Object.assign({}, p.transform),
                    original: Object.assign({}, p.original),
                    meterScale: p.meterScale,
                    geo: p.geo ? { lng: p.geo.lng, lat: p.geo.lat, alt: p.geo.alt } : null,
                    animated: !!p.animated,
                    spinSpeed: (p.spinSpeed || 0.2),
                    originalGeoLat: p.originalGeoLat,
                    originalGeoLng: p.originalGeoLng
                };
            }
            return {
                id: p.id,
                url: p.url || defaultModelUrl,
                name: p.name,
                transform: Object.assign({}, p.transform),
                original: Object.assign({}, p.original),
                meterScale: p.meterScale,
                geo: p.geo ? { lng: p.geo.lng, lat: p.geo.lat, alt: p.geo.alt } : null,
                animated: !!p.animated,
                spinSpeed: (p.spinSpeed || 0.2),
                originalGeoLat: p.originalGeoLat,
                originalGeoLng: p.originalGeoLng
            };
        });
    }
    // helper to restore parsed state object (used by URL restore)
    function restoreSavedState(parsed) {
        try {
            if (parsed.mapCenter) map.setCenter(parsed.mapCenter);
            if (parsed.zoom) map.setZoom(parsed.zoom);
            if (parsed.pitch) map.setPitch(parsed.pitch);
            if (parsed.bearing) map.setBearing(parsed.bearing);
            // clear existing models
            placedModels.slice().forEach(p => removeModel(p.id));
            // restore saved models
                (parsed.models || []).forEach(m => {
                    // prepare a normalized item for restore
                    const item = Object.assign({}, m);
                    // If the custom layer is ready, restore immediately; otherwise queue it
                    if (item.type === '3dtext') {
                        if (modelLayerRef && modelLayerRef.load3DText) {
                            try {
                                const transform = Object.assign({}, item.transform);
                                if (item.animated) transform.animated = true;
                                const geo = item.geo ? [item.geo.lng, item.geo.lat, item.geo.alt || 0] : null;
                                modelLayerRef.load3DText(item.text || item.name || 'Text', transform, geo, item.id, item.name);
                            } catch (e) { console.warn('Failed to restore 3dtext immediately', e); }
                        } else {
                            _restoreQueue.push(item);
                        }
                        return;
                    }
                    // regular model entry
                    if (modelLayerRef && modelLayerRef.loadModel) {
                        try {
                            const url = (item.url && item.url.length) ? item.url : defaultModelUrl;
                            const transform = Object.assign({}, item.transform);
                            if (item.animated) transform.animated = true;
                            const geo = item.geo ? [item.geo.lng, item.geo.lat, item.geo.alt || 0] : null;
                            modelLayerRef.loadModel(encodeURI(url), transform, geo, item.id, item.name);
                        } catch (e) { console.warn('Failed to restore model immediately', e); }
                    } else {
                        _restoreQueue.push(item);
                    }
                });
            // restore drawn features if present in shared state
            try {
                if (parsed.draws && Array.isArray(parsed.draws)) {
                    drawnFeatures = parsed.draws.slice();
                    // Always apply draw features immediately, regardless of draw tool state
                    const applyDraws = () => {
                        try { ensureDrawSourceAndLayers(); } catch (e) { console.warn('ensureDrawSourceAndLayers failed', e); }
                        try {
                            if (map.getSource && map.getSource('draw-source')) {
                                map.getSource('draw-source').setData({ type: 'FeatureCollection', features: drawnFeatures });
                            }
                        } catch (e) { console.warn('Failed to set draw-source data', e); }
                        try { console.debug && console.debug('applyDraws: drawnFeatures count', drawnFeatures && drawnFeatures.length, 'layers:', !!map.getLayer && !!map.getLayer('draw-labels'), !!map.getLayer && !!map.getLayer('draw-lines')); } catch (e) {}
                        try { refreshDrawSource(); } catch (e) {}
                        try { if (map && map.triggerRepaint) map.triggerRepaint(); } catch (e) {}
                        try { nudgeDrawLayers(); } catch (e) {}
                    };
                    if (typeof map.isStyleLoaded === 'function' && !map.isStyleLoaded()) {
                        console.debug && console.debug('restoreSavedState: style not loaded, waiting for style.load to apply draws');
                        map.once('style.load', applyDraws);
                    } else {
                        console.debug && console.debug('restoreSavedState: applying draws immediately');
                        applyDraws();
                    }
                }
            } catch (e) { console.warn('Failed to restore draws from shared state', e); }
            try { applyTextSizeToLayer && applyTextSizeToLayer(selectedTextSize); } catch (e) {}
            renderSidebar();
            // Extra safety: repeatedly nudge and re-apply draw layers after restore
            try { forceDrawVisibility(6, 300); } catch (e) {}
        } catch (e) { console.warn('Failed to restore parsed state', e); }
    }

    shareBtn.addEventListener('click', () => {
        (async () => {
            try {
                const data = serializePlacedModels();
                const payload = { mapCenter: map.getCenter(), zoom: map.getZoom(), pitch: map.getPitch(), bearing: map.getBearing(), models: data, draws: drawnFeatures };
                if (BACKEND_STATE_ENDPOINT && BACKEND_STATE_ENDPOINT.length) {
                    // POST to backend which returns { id: '8char' }
                    try { console.debug('Sharing payload FULL', payload); } catch (e) {}
                    const res = await fetch(BACKEND_STATE_ENDPOINT, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ state: payload })
                    });
                    if (!res.ok) throw new Error('Backend save failed: ' + res.status);
                    const j = await res.json();
                    try { console.debug('Backend save response', j); } catch (e) {}
                    const id = j && j.id;
                    if (!id) throw new Error('Invalid response from backend');
                    const url = location.origin + location.pathname + '?state_id=' + encodeURIComponent(id);
                    // Try Web Share API first (native share sheet on mobile), then clipboard, then prompt fallback
                    try {
                        if (navigator.share) {
                            await navigator.share({url});
                            return;
                        }
                    } catch (e) {
                        // ignore and try clipboard fallback
                        console.warn('navigator.share failed', e);
                    }
                    try {
                        if (navigator.clipboard && navigator.clipboard.writeText) {
                            await navigator.clipboard.writeText(url);
                            alert('Short share URL copied to clipboard');
                            return;
                        }
                    } catch (e) {
                        console.warn('clipboard write failed', e);
                    }
                    // Final fallback: show the URL in a prompt so the user can copy manually
                    try { window.prompt('Copy this URL', url); } catch (e) { alert(url); }
                } else {
                    // fallback: embed long state in URL (legacy behavior)
                    const b64 = btoa(unescape(encodeURIComponent(JSON.stringify(payload))));
                    const url = location.origin + location.pathname + '?state=' + encodeURIComponent(b64);
                    try {
                        if (navigator.share) {
                            await navigator.share({ url });
                            return;
                        }
                    } catch (e) { console.warn('navigator.share failed', e); }
                    try {
                        if (navigator.clipboard && navigator.clipboard.writeText) {
                            await navigator.clipboard.writeText(url);
                            alert('Share URL copied to clipboard');
                            return;
                        }
                    } catch (e) { console.warn('clipboard write failed', e); }
                    try { window.prompt('Copy this URL', url); } catch (e) { alert(url); }
                }
            } catch (e) { alert('Failed to create share URL: ' + (e && e.message)); }
        })();
    });

    // Try to restore state from URL params on load: prefer short ?state_id= when backend is used
    (function tryRestoreFromUrl(){
        try {
            const params = new URLSearchParams(window.location.search);
            const id = params.get('state_id');
            const s = params.get('state');
            if (id && BACKEND_STATE_ENDPOINT && BACKEND_STATE_ENDPOINT.length) {
                // fetch from backend by id
                setTimeout(async () => {
                    try {
                        const res = await fetch(BACKEND_STATE_ENDPOINT + '/' + encodeURIComponent(id));
                        if (!res.ok) { console.warn('Failed to load state id', id); return; }
                        const j = await res.json();
                        try { console.debug('Loaded saved state from backend', j); } catch (e) {}
                        if (j && j.state) restoreSavedState(j.state);
                    } catch (e) { console.warn('Failed to load state from backend', e); }
                }, 500);
                return;
            }
            if (!s) return;
            const json = decodeURIComponent(atob(s));
            const parsed = JSON.parse(json);
            // delay restoring until map and model layer ready
            setTimeout(() => { restoreSavedState(parsed); }, 500);
        } catch (e) { console.warn('Failed to restore from URL', e); }
    })();

    // helpers to convert mercator deltas to lat/lng deltas
    function metersPerDegreeAtLat(latDeg) {
        const lat = latDeg * Math.PI / 180;
        // approximate constants
        const mPerDegLat = 111132.92 - 559.82 * Math.cos(2 * lat) + 1.175 * Math.cos(4 * lat);
        const mPerDegLng = 111412.84 * Math.cos(lat) - 93.5 * Math.cos(3 * lat);
        return { mPerDegLat, mPerDegLng };
    }

    function updateEntryGeo(entry) {
        if (!entry || !entry.original || !entry.geo || !entry.meterScale) return;
        // compute mercator delta from original transform
        const dx = entry.transform.translateX - entry.original.translateX;
        const dy = entry.transform.translateY - entry.original.translateY;
        // convert mercator units to meters using stored meterScale
        const deltaEastMeters = dx / entry.meterScale;
        const deltaNorthMeters = dy / entry.meterScale;
        // compute degrees per meter approx at original latitude
        const origLat = entry.originalGeoLat !== undefined && entry.originalGeoLat !== null ? entry.originalGeoLat : entry.geo.lat;
        const { mPerDegLat, mPerDegLng } = metersPerDegreeAtLat(origLat);
        const deltaLatDeg = deltaNorthMeters / mPerDegLat;
        const deltaLngDeg = deltaEastMeters / mPerDegLng;
        entry.geo.lat = (entry.originalGeoLat !== undefined && entry.originalGeoLat !== null) ? (entry.originalGeoLat + deltaLatDeg) : (entry.geo.lat + deltaLatDeg);
        entry.geo.lng = (entry.originalGeoLng !== undefined && entry.originalGeoLng !== null) ? (entry.originalGeoLng + deltaLngDeg) : (entry.geo.lng + deltaLngDeg);
    }

    // store placed models (support multiple models)
    // each entry: { id, name, transform, original, meterScale, object }
    const placedModels = [];
    let selectedModelId = null; // id of the model currently controlled

    // --- sidebar for placed models ---
    const sidebar = document.createElement('div');
    sidebar.id = 'sidebar';
    sidebar.className = 'hidden';
    sidebar.innerHTML = '<div style="font-weight:700;margin-bottom:8px">Placed models</div><div id="models-list"></div>';
    document.body.appendChild(sidebar);

    // toggle sidebar open/close
    modelsBtn.addEventListener('click', () => {
        const wasHidden = sidebar.classList.contains('hidden');
        sidebar.classList.toggle('hidden');
        modelsBtn.textContent = wasHidden ? 'Close' : 'Info';
        if (wasHidden) renderSidebar();
    });

    function renderSidebar() {
        const list = document.getElementById('models-list');
        list.innerHTML = '';
        placedModels.forEach((entry, idx) => {
            const row = document.createElement('div');
            row.className = 'model-row' + (entry.id === selectedModelId ? ' selected' : '');
            row.dataset.id = entry.id;

            const label = document.createElement('span');
            label.className = 'label';
            label.textContent = entry.name || ('Model ' + (idx + 1));
            label.style.cursor = 'pointer';
            label.addEventListener('click', () => selectModel(entry.id));

            // info: coordinates and rotation
            const info = document.createElement('div');
            info.className = 'info';
            const coordText = entry.geo ? `Lng: ${entry.geo.lng.toFixed(6)}, Lat: ${entry.geo.lat.toFixed(6)}, Alt: ${entry.geo.alt}` : '';
            const rotDeg = `R:${((entry.transform.rotateY*180/Math.PI)||0).toFixed(1)}°`;
            info.textContent = (coordText ? coordText + ' • ' : '') + rotDeg;

            const leftCol = document.createElement('div');
            leftCol.className = 'model-left';
            leftCol.appendChild(label);
            leftCol.appendChild(info);

            const actions = document.createElement('div');
            actions.className = 'model-actions';

            const renameBtn = document.createElement('button');
            renameBtn.textContent = 'Rename';
            renameBtn.addEventListener('click', () => {
                const input = document.createElement('input');
                input.type = 'text';
                input.value = entry.name || '';
                input.className = 'rename-input';
                input.addEventListener('blur', () => { entry.name = input.value || entry.name; renderSidebar(); });
                input.addEventListener('keydown', e => { if (e.key === 'Enter') input.blur(); });
                leftCol.replaceChild(input, label);
                input.focus();
            });
            actions.appendChild(renameBtn);

            const delBtn = document.createElement('button');
            delBtn.textContent = 'Remove';
            delBtn.addEventListener('click', () => removeModel(entry.id));
            actions.appendChild(delBtn);

            row.appendChild(leftCol);
            row.appendChild(actions);
            list.appendChild(row);
        });
    }

    function selectModel(id) {
        selectedModelId = id;
        const entry = placedModels.find(p => p.id === id);
        if (!entry) return;
        setControlsDisabled(false);
    if (rot) rot.value = Math.round((entry.transform.rotateY * 180 / Math.PI) * 100) / 100;
        scaleInput.value = Math.round((entry.transform.scale / (entry.meterScale || 1)) * 100) / 100;
        // sync animate button text to reflect entry state
        try {
            const animateBtn = document.getElementById('animateBtn');
            if (animateBtn) animateBtn.textContent = entry.animated ? 'Stop animation' : 'Animate';
        } catch (e) {}
        // sync spinSpeed input
        try {
            const spinInput = document.getElementById('spinSpeed');
            if (spinInput) spinInput.value = (entry.spinSpeed !== undefined) ? entry.spinSpeed : 0.2;
        } catch (e) {}
        renderSidebar();
        if (map) map.triggerRepaint();
    }

    function removeModel(id) {
        const idx = placedModels.findIndex(p => p.id === id);
        if (idx === -1) return;
        const entry = placedModels[idx];
        if (modelLayerRef && entry.object) {
            try { modelLayerRef.scene.remove(entry.object); } catch (e) { console.warn(e); }
        }
        placedModels.splice(idx, 1);
        if (selectedModelId === id) {
            selectedModelId = null;
            setControlsDisabled(true);
        }
        renderSidebar();
        if (map) map.triggerRepaint();
    }

    // variables used by the custom three.js layer
    let modelLayerRef = null; // set in onAdd
    // queue for restoring models when the custom layer isn't ready yet
    const _restoreQueue = [];

    function processRestoreQueue() {
        if (!modelLayerRef) return;
        while (_restoreQueue.length) {
            const item = _restoreQueue.shift();
            try {
                console.debug && console.debug('processRestoreQueue: restoring item', item && (item.id || item.name || item.type));
                if (item.type === '3dtext' && modelLayerRef.load3DText) {
                    modelLayerRef.load3DText(item.text || item.name || 'Text', Object.assign({}, item.transform), item.geo ? [item.geo.lng, item.geo.lat, item.geo.alt || 0] : null, item.id, item.name);
                } else if (modelLayerRef.loadModel) {
                    const url = (item.url && item.url.length) ? item.url : defaultModelUrl;
                    modelLayerRef.loadModel(encodeURI(url), Object.assign({}, item.transform), item.geo ? [item.geo.lng, item.geo.lat, item.geo.alt || 0] : null, item.id, item.name);
                }
                // After requesting load, also ensure drawn features are applied so symbols/lines appear
                try {
                    ensureDrawSourceAndLayers();
                    if (map.getSource && map.getSource('draw-source')) map.getSource('draw-source').setData({ type: 'FeatureCollection', features: drawnFeatures });
                    try { refreshDrawSource(); } catch (e) {}
                    try { if (map && map.triggerRepaint) map.triggerRepaint(); } catch (e) {}
                    try { nudgeDrawLayers(); } catch (e) {}
                } catch (e) { console.warn('Failed to re-apply draws during restore queue', e); }
            } catch (e) { console.warn('processRestoreQueue item failed', e); }
        }
    }

    // create the custom layer (empty scene initially)
    const customLayer = {
        id: '3d-model',
        type: 'custom',
        renderingMode: '3d',
        onAdd: function (map, gl) {
            this.camera = new THREE.Camera();
            this.scene = new THREE.Scene();
            this.loader = new THREE.GLTFLoader();

            // use an ambient light so the model is uniformly lit
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
            this.scene.add(ambientLight);

            this.map = map;
            // Creating a WebGLRenderer using the map's GL context can fail on
            // some mobile browsers or low-resource environments. Wrap in try/catch
            // and gracefully disable the 3D layer when unavailable.
            try {
                this.renderer = new THREE.WebGLRenderer({
                    canvas: map.getCanvas(),
                    context: gl,
                    antialias: true
                });
                this.renderer.autoClear = false;
            } catch (err) {
                console.warn('Three.js renderer creation failed; disabling 3D layer', err);
                // mark layer as disabled so render() is a no-op
                this._disabled = true;
                modelLayerRef = null;
                return;
            }

            // expose ref so outer code can call loadModel
            modelLayerRef = this;
            // process any queued restore items now that the layer is ready
            try { processRestoreQueue(); } catch (e) { console.warn('processRestoreQueue failed on onAdd', e); }
            // After custom layer is ready, force draw visibility again
            setTimeout(() => {
                try { console.debug('Custom layer ready, forcing draw visibility'); forceDrawVisibility(6, 300); } catch (e) {}
            }, 400);

            // helper to create a 3D text entry (used when restoring serialized state)
            this.load3DText = (text, transform, geo, preferredId, preferredName) => {
                try {
                    const loader = new THREE.FontLoader();
                    const id = preferredId || ('text_' + Date.now());
                    loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
                        const geom = new THREE.TextGeometry(text, { font, size: 1, height: 0.3, curveSegments: 8 });
                        geom.computeBoundingBox();
                        geom.center();
                        const mat = new THREE.MeshBasicMaterial({ color: 0xff6a00 });
                        const mesh = new THREE.Mesh(geom, mat);
                        mesh.position.set(0,0,0);
                        mesh.scale.set(1,1,1);
                        const entry = {
                            id,
                            name: preferredName || text,
                            text: text,
                            type: '3dtext',
                            transform: Object.assign({}, transform),
                            original: Object.assign({}, transform),
                            meterScale: transform.scale,
                            object: mesh,
                            animated: !!transform.animated,
                            spinSpeed: transform.spinSpeed || 0.2,
                            url: null,
                            geo: geo ? { lng: geo[0], lat: geo[1], alt: geo[2] || 0 } : null,
                            originalGeoLat: geo ? geo[1] : null,
                            originalGeoLng: geo ? geo[0] : null
                        };
                        placedModels.push(entry);
                        this.scene.add(mesh);
                        try { renderSidebar(); } catch (e) {}
                        try { if (this.map && this.map.triggerRepaint) this.map.triggerRepaint(); } catch (e) {}
                        try { nudgeDrawLayers(); } catch (e) {}
                    }, undefined, (err) => { console.warn('Font load failed for load3DText', err); });
                    return id;
                } catch (e) { console.warn('load3DText failed', e); }
            };

            // helper to load a GLTF into the scene without clearing previous models
            // accepts (url, transform) and returns an id for the placed model
        // loadModel(url, transform, geo, preferredId, preferredName)
        // Accept optional preferredId and preferredName so restored states can keep original ids and names
        this.loadModel = (url, transform, geo, preferredId, preferredName) => {
                const id = preferredId || (String(Date.now()) + '-' + Math.floor(Math.random() * 10000));
        const entry = {
            id,
            name: preferredName || ('Model ' + (placedModels.length + 1)),
        transform: Object.assign({}, transform),
            original: Object.assign({}, transform),
            meterScale: transform.scale,
    object: null,
    animated: !!(transform && transform.animated),
    spinSpeed: (transform && transform.spinSpeed) ? transform.spinSpeed : 0.2,
        // persist the original URL so serializePlacedModels can save it
        url: url,
        geo: geo ? { lng: geo[0], lat: geo[1], alt: geo[2] || 0 } : null,
        originalGeoLat: geo ? geo[1] : null,
        originalGeoLng: geo ? geo[0] : null
        };
                placedModels.push(entry);
                renderSidebar();
                // load new gltf and attach to scene when ready
                try {
                // Queue the load to avoid too many concurrent requests on mobile
                enqueueLoad(this.loader, url,
                    (gltf) => {
                        // convert materials to MeshBasicMaterial for uniform lighting
                        // If this is the restroom model, force an orange color for visibility
                        const isRestroom = (url && url.includes('restroom_model.glb')) || (preferredName && String(preferredName).toLowerCase().includes('restroom'));
                        gltf.scene.traverse(function (child) {
                            if (child.isMesh) {
                                try {
                                    const oldMat = child.material || {};
                                    const params = {};
                                    // for non-restroom models, preserve texture maps where available
                                    if (!isRestroom && oldMat.map) params.map = oldMat.map;
                                    // set color: force orange for restroom, otherwise preserve existing color if present
                                    if (isRestroom) {
                                        params.color = new THREE.Color(0xff6a00);
                                    } else if (oldMat.color) {
                                        params.color = oldMat.color.clone();
                                    }
                                    if (oldMat.opacity !== undefined) {
                                        params.opacity = oldMat.opacity;
                                        params.transparent = oldMat.transparent;
                                    }
                                    child.material = new THREE.MeshBasicMaterial(params);
                                    if (isRestroom) {
                                        // ensure any previous texture references don't interfere
                                        try { child.material.map = null; } catch (e) {}
                                        child.material.needsUpdate = true;
                                    }
                                } catch (e) {
                                    console.warn('Failed to convert material to MeshBasicMaterial', e);
                                }
                            }
                        });
                        // center the model geometry so rotations occur around its center
                        try {
                            const obj = gltf.scene || gltf.scenes[0];
                            const box = new THREE.Box3().setFromObject(obj);
                            const center = box.getCenter(new THREE.Vector3());
                            // move the model so its center is at the origin (pivot)
                            obj.position.x -= center.x;
                            obj.position.y -= center.y;
                            obj.position.z -= center.z;
                        } catch (e) {
                            console.warn('Failed to center model', e);
                        }
                        entry.object = gltf.scene;
                        this.scene.add(gltf.scene);
                        try { renderSidebar(); } catch (e) {}
                        try { if (this.map && this.map.triggerRepaint) this.map.triggerRepaint(); } catch (e) {}
                        try { nudgeDrawLayers(); } catch (e) {}
                    },
                    undefined,
                    (err) => {
                        console.error('Error loading GLTF:', err);
                        alert('Failed to load model. See console for details.');
                    }
                );
                } catch (e) {
                    console.error('Loader error', e);
                }
                return id;
            };
        },
        render: function (gl, matrix) {
            // no-op when layer disabled due to missing WebGL support
            if (this._disabled) return;

            if (!placedModels.length) return;

            const m = new THREE.Matrix4().fromArray(matrix);

            // render each placed model separately
            for (let i = 0; i < placedModels.length; i++) {
                const entry = placedModels[i];
                if (!entry.object) continue; // not loaded yet

                // if entry is animated, apply a Y-axis spin using its spinSpeed
                if (entry.animated) {
                    const speed = (entry.spinSpeed !== undefined) ? entry.spinSpeed : 0.2;
                    entry.transform.rotateY = (entry.transform.rotateY || 0) + speed;
                }

                const rotationX = new THREE.Matrix4().makeRotationAxis(
                    new THREE.Vector3(1, 0, 0),
                    entry.transform.rotateX
                );
                const rotationY = new THREE.Matrix4().makeRotationAxis(
                    new THREE.Vector3(0, 1, 0),
                    entry.transform.rotateY
                );
                const rotationZ = new THREE.Matrix4().makeRotationAxis(
                    new THREE.Vector3(0, 0, 1),
                    entry.transform.rotateZ
                );

                const l = new THREE.Matrix4()
                    .makeTranslation(
                        entry.transform.translateX,
                        entry.transform.translateY,
                        entry.transform.translateZ
                    )
                    .scale(
                        new THREE.Vector3(
                            entry.transform.scale,
                            -entry.transform.scale,
                            entry.transform.scale
                        )
                    )
                    .multiply(rotationX)
                    .multiply(rotationY)
                    .multiply(rotationZ);

                // hide all model objects except the one we're rendering
                for (let c = 0; c < this.scene.children.length; c++) {
                    const child = this.scene.children[c];
                    if (child.type === 'AmbientLight') continue;
                    child.visible = (child === entry.object) || (child.type === 'AmbientLight');
                }

                const cameraMatrix = new THREE.Matrix4().copy(m).multiply(l);
                this.camera.projectionMatrix = cameraMatrix;
                this.renderer.resetState();
                this.renderer.render(this.scene, this.camera);
            }

            // ensure all children visible again
            for (let c = 0; c < this.scene.children.length; c++) {
                this.scene.children[c].visible = true;
            }

            this.map.triggerRepaint();
        }
    };

    // add the custom layer at startup so the three.js scene is ready
    // Provide a helper to hide any fill-extrusion / building layers. Some styles add these layers
    // asynchronously, so we run this on style.load and again on style/data events.
    function hideBuildings() {
        try {
            const style = map.getStyle();
            if (style && style.layers && Array.isArray(style.layers)) {
                style.layers.forEach(l => {
                    try {
                        const id = l && l.id;
                        const type = l && l.type;
                        const lname = String(id || '').toLowerCase();
                        if (type === 'fill-extrusion' || lname.includes('building') || lname.includes('extrusion')) {
                            try { map.setLayoutProperty(id, 'visibility', 'none'); } catch (e) {}
                            try { map.setPaintProperty(id, 'fill-extrusion-opacity', 0); } catch (e) {}
                            try { map.setPaintProperty(id, 'fill-extrusion-color', '#000000'); } catch (e) {}
                        }
                    } catch (e) { /* ignore per-layer */ }
                });
            }
        } catch (e) { /* ignore style introspection errors */ }
    }

    // helper to ensure our custom layer exists exactly once
    function ensureCustomLayerPresent() {
        try {
            const existing = map.getStyle && map.getStyle().layers && map.getStyle().layers.find(l => l.id === customLayer.id);
            if (!existing) {
                try { map.addLayer(customLayer); } catch (e) { console.warn('Failed to add customLayer', e); }
            }
        } catch (e) { console.warn('ensureCustomLayerPresent error', e); }
    }

    map.on('style.load', () => {
        // run hideBuildings immediately and a couple times after load to catch dynamic additions
        hideBuildings();
        setTimeout(hideBuildings, 300);
        setTimeout(hideBuildings, 1200);
        // ensure our custom three.js layer is present after the new style is applied
        ensureCustomLayerPresent();
        // also (re)attach style/data listeners which may add layers after style.load
        try { map.off && map.off('styledata', hideBuildings); } catch (e) {}
        try { map.off && map.off('sourcedata', hideBuildings); } catch (e) {}
        try { map.off && map.off('data', hideBuildings); } catch (e) {}
        try { map.on('styledata', hideBuildings); } catch (e) {}
        try { map.on('sourcedata', hideBuildings); } catch (e) {}
        try { map.on('data', hideBuildings); } catch (e) {}
    });

    // convert the GitHub blob URL to a raw.githubusercontent.com URL
    function githubBlobToRaw(url) {
        try {
            const u = new URL(url);
            // expects: https://github.com/{owner}/{repo}/blob/{branch}/{path}
            const parts = u.pathname.split('/');
            const blobIndex = parts.indexOf('blob');
            if (u.hostname === 'github.com' && blobIndex > -1) {
                const owner = parts[1];
                const repo = parts[2];
                const branch = parts[blobIndex + 1];
                const path = parts.slice(blobIndex + 2).join('/');
                return `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${path}`;
            }
        } catch (e) {
            // fall through
        }
        return url;
    }

    // support clicking on the map to place the model when in placingModel mode
    map.on('click', async (e) => {
        const lngLat = [e.lngLat.lng, e.lngLat.lat];

        if (!placingModel) {
            // selection flow: find nearest placed model to click and select it
            if (placedModels.length) {
                const clicked = mapboxgl.MercatorCoordinate.fromLngLat(lngLat, 0);
                let best = null;
                let bestDist = Infinity;
                for (const p of placedModels) {
                    const dx = p.transform.translateX - clicked.x;
                    const dy = p.transform.translateY - clicked.y;
                    const dz = p.transform.translateZ - clicked.z;
                    const d2 = dx*dx + dy*dy + dz*dz;
                    if (d2 < bestDist) {
                        bestDist = d2;
                        best = p;
                    }
                }
                if (best) {
                    const threshold = Math.pow(50 * (best.meterScale || 1), 2); // ~50 meters
                    if (bestDist < threshold) {
                        selectedModelId = best.id;
                        if (rot) rot.value = Math.round((best.transform.rotateY * 180 / Math.PI) * 100) / 100;
                        scaleInput.value = Math.round((best.transform.scale / (best.meterScale || 1)) * 100) / 100;
                        setControlsDisabled(false);
                    }
                }
            }
            return;
        }

        // placing flow
        if (placingText && placingText.text) {
            // place 3D text at click location
            try {
                await add3DText(placingText.text, lngLat, { size: 1.5, height: 0.25, color: 0xff6a00 });
                placingText = null;
                note.textContent = 'Click on the map to place the model, or click the button again to cancel.';
                note.style.display = 'none';
            } catch (e) {
                console.warn('Failed to place 3D text', e);
                alert('Failed to place 3D text');
            }
            if (map) map.triggerRepaint();
            return;
        }

        const altitude = 0;
        const modelAsMercatorCoordinate = mapboxgl.MercatorCoordinate.fromLngLat(
            lngLat,
            altitude
        );

        // build a transform for the new model
            const transform = {
            translateX: modelAsMercatorCoordinate.x,
            translateY: modelAsMercatorCoordinate.y,
            translateZ: modelAsMercatorCoordinate.z,
            rotateX: Math.PI / 2,
            rotateY: 0,
            rotateZ: 0,
            // apply any per-model override (e.g., truck defaultScale)
            scale: modelAsMercatorCoordinate.meterInMercatorCoordinateUnits() * (modelScaleOverride || 1)
        };

    // load the model into the three.js scene
    const rawUrl = githubBlobToRaw(modelUrl);
    if (modelLayerRef && modelLayerRef.loadModel) {
            const id = modelLayerRef.loadModel(encodeURI(rawUrl), transform, lngLat.concat([0]));
            selectedModelId = id;

            // find the placed model entry and enable controls for it
            const entry = placedModels.find(p => p.id === id);
            if (entry) {
                entry.meterScale = entry.meterScale || modelAsMercatorCoordinate.meterInMercatorCoordinateUnits();
                entry.original = Object.assign({}, entry.transform);

                setControlsDisabled(false);
                if (rot) rot.value = Math.round((entry.transform.rotateY * 180 / Math.PI) * 100) / 100;
                scaleInput.value = 1;
            }
        }

    // keep placingMode active so multiple models can be placed
    // (user can click Add model again to cancel)
        if (map) map.triggerRepaint();
    });

    // --- Model hover tooltip (show model name when cursor is near a placed model) ---
    const modelTooltip = document.createElement('div');
    modelTooltip.id = 'model-tooltip';
    modelTooltip.style.position = 'absolute';
    modelTooltip.style.pointerEvents = 'none';
    modelTooltip.style.padding = '6px 8px';
    modelTooltip.style.background = 'rgba(255,255,255,0.95)';
    modelTooltip.style.border = '1px solid rgba(0,0,0,0.08)';
    modelTooltip.style.borderRadius = '6px';
    modelTooltip.style.fontFamily = 'sans-serif';
    modelTooltip.style.fontSize = '13px';
    modelTooltip.style.color = '#0f1724';
    modelTooltip.style.zIndex = '10';
    modelTooltip.style.display = 'none';
    document.body.appendChild(modelTooltip);

    let hoveredModelId = null;

    function hideModelTooltip() {
        hoveredModelId = null;
        modelTooltip.style.display = 'none';
    }

    // Use pixel-distance hover detection: project each model's geo to screen and compare to mouse point
    map.on('mousemove', (e) => {
        if (!placedModels || !placedModels.length) { hideModelTooltip(); return; }
        const mousePoint = e.point; // pixel coords relative to map container
        let bestEntry = null;
        let bestProj = null;
        let bestDist2 = Infinity;
        for (const p of placedModels) {
            if (!p.geo || p.geo.lng === undefined || p.geo.lat === undefined) continue;
            const proj = map.project([p.geo.lng, p.geo.lat]);
            const dx = proj.x - mousePoint.x;
            const dy = proj.y - mousePoint.y;
            const d2 = dx*dx + dy*dy;
            if (d2 < bestDist2) { bestDist2 = d2; bestEntry = p; bestProj = proj; }
        }
        if (!bestEntry) { hideModelTooltip(); return; }
        const pixelThreshold = 40; // hover radius in pixels
        if (bestDist2 <= (pixelThreshold * pixelThreshold)) {
            if (hoveredModelId !== bestEntry.id) {
                hoveredModelId = bestEntry.id;
                modelTooltip.textContent = bestEntry.name || ('Model ' + bestEntry.id);
            }
            // position tooltip near mouse pointer using absolute page coords
            const canvasRect = map.getCanvas().getBoundingClientRect();
            const absLeft = canvasRect.left + mousePoint.x;
            const absTop = canvasRect.top + mousePoint.y;
            modelTooltip.style.left = (absLeft + 12) + 'px';
            modelTooltip.style.top = (absTop + 12) + 'px';
            modelTooltip.style.display = 'block';
        } else {
            hideModelTooltip();
        }
    });

    // hide tooltip when mouse leaves the map canvas
    const canvas = map.getCanvas && map.getCanvas();
    if (canvas) canvas.addEventListener('mouseleave', hideModelTooltip);

// --- Address / location bar (bottom) ---
const addressBar = document.createElement('div');
addressBar.id = 'address-bar';
addressBar.innerHTML = `
    <input id="address-input" placeholder="Enter address or lng,lat (e.g. -79.3875,43.6426)" />
    <button id="address-go" class="btn">Go</button>
    <button id="address-clear" class="btn secondary">Clear</button>
`;
document.body.appendChild(addressBar);

const addressInput = document.getElementById('address-input');
const addressGo = document.getElementById('address-go');
const addressClear = document.getElementById('address-clear');
let addressMarker = null;

function clearAddressMarker() {
    if (addressMarker) {
        try { addressMarker.remove(); } catch (e) {}
        addressMarker = null;
    }
}

addressClear.addEventListener('click', () => {
    clearAddressMarker();
});

// --- Address suggestions and POI search ---
// small, editable local POI directory (can be extended or loaded from a remote source)
const localPOIs = [
    { id: 'poi_airport', name: 'Pearson International Airport', coords: [-79.611, 43.677], desc: 'Airport' },
    { id: 'poi_cn_tower', name: 'CN Tower', coords: [-79.3875, 43.6426], desc: 'Landmark' },
    { id: 'poi_union', name: 'Union Station', coords: [-79.3792, 43.6452], desc: 'Transit' },
    { id: 'poi_scotia', name: 'Scotiabank Arena', coords: [-79.3789, 43.6435], desc: 'Sports/Events' },
    { id: 'poi_rogers', name: 'Rogers Centre', coords: [-79.3906, 43.6416], desc: 'Stadium' }
];

// Create a suggestions container attached to the address bar
const suggestions = document.createElement('div');
suggestions.id = 'address-suggestions';
suggestions.className = 'hidden';
suggestions.style.boxSizing = 'border-box';
suggestions.style.width = '100%';
suggestions.style.maxHeight = '220px';
suggestions.style.overflowY = 'auto';
suggestions.style.background = '#ffffff';
suggestions.style.border = '1px solid rgba(0,0,0,0.08)';
suggestions.style.borderRadius = '6px';
suggestions.style.marginTop = '6px';
suggestions.style.padding = '6px 0';
suggestions.style.zIndex = '40';
addressBar.appendChild(suggestions);

let suggestionItems = [];
let suggestionSelected = -1; // index for keyboard nav

// small helper to render suggestion list
function renderSuggestions(items) {
    suggestionItems = items || [];
    suggestionSelected = -1;
    suggestions.innerHTML = '';
    if (!items || !items.length) {
        suggestions.classList.add('hidden');
        return;
    }
    suggestions.classList.remove('hidden');
    items.forEach((it, idx) => {
        const row = document.createElement('button');
        row.type = 'button';
        row.className = 'suggestion-row';
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.gap = '8px';
        row.style.width = '100%';
        row.style.border = 'none';
        row.style.background = 'transparent';
        row.style.padding = '8px 12px';
        row.style.textAlign = 'left';
        row.style.cursor = 'pointer';
        row.onmouseover = () => { highlightSuggestion(idx); };
        row.onmouseout = () => { highlightSuggestion(-1); };
        row.onclick = () => { selectSuggestion(it); };

        const title = document.createElement('div');
        title.textContent = it.title || it.name || '';
        title.style.fontSize = '14px';
        title.style.color = '#0f1724';
        const sub = document.createElement('div');
        sub.textContent = it.subtitle || (it.desc || (it.source === 'mapbox' && it.place_name) || '');
        sub.style.fontSize = '12px';
        sub.style.color = '#6b7280';
        const col = document.createElement('div');
        col.style.display = 'flex';
        col.style.flexDirection = 'column';
        col.appendChild(title);
        col.appendChild(sub);
        row.appendChild(col);

        suggestions.appendChild(row);
    });
}

function highlightSuggestion(idx) {
    const rows = suggestions.querySelectorAll('.suggestion-row');
    rows.forEach((r, i) => {
        r.style.background = (i === idx) ? 'rgba(15,23,36,0.06)' : 'transparent';
    });
    suggestionSelected = idx;
}

function selectSuggestion(item) {
    try { suggestions.classList.add('hidden'); } catch (e) {}
    if (!item) return;
    // item may be local POI: { name, coords } or Mapbox feature: { center: [lng,lat], place_name }
    let coords = null;
    if (item.coords) coords = item.coords;
    else if (item.center) coords = item.center;
    else if (item.lng !== undefined && item.lat !== undefined) coords = [item.lng, item.lat];
    else if (item.geometry && item.geometry.coordinates) coords = item.geometry.coordinates;
    if (coords) {
        addressInput.value = item.name || item.place_name || `${coords[0].toFixed(6)},${coords[1].toFixed(6)}`;
        map.flyTo({ center: coords, zoom: 18, essential: true });
        clearAddressMarker();
        addressMarker = new mapboxgl.Marker({ color: '#ff6a00' }).setLngLat(coords).addTo(map);
    } else {
        // fallback to filling input
        addressInput.value = item.title || item.name || '';
    }
}

// Mapbox forward-suggest (returns array of features)
async function geocodeSuggest(query) {
    try {
        const token = mapboxgl.accessToken;
        const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(query)}.json?access_token=${token}&autocomplete=true&limit=6`;
        const res = await fetch(url);
        if (!res.ok) return [];
        const j = await res.json();
        if (j && j.features) return j.features.map(f => ({ source: 'mapbox', place_name: f.place_name, center: f.center, geometry: f.geometry }));
    } catch (e) { console.warn('Suggest failed', e); }
    return [];
}

// debounce the suggestion lookup to avoid spamming the API
const debouncedSuggest = debounce(async (txt) => {
    if (!txt || txt.length < 2) {
        renderSuggestions([]);
        return;
    }
    const q = txt.trim();
    // local matches first
    const local = localPOIs.filter(p => p.name.toLowerCase().includes(q.toLowerCase())).map(p => ({ title: p.name, coords: p.coords, subtitle: p.desc, source: 'local' }));
    // remote suggestions
    let remote = [];
    try { remote = await geocodeSuggest(q); } catch (e) { remote = []; }
    // merge, avoid duplicates by place_name/coords
    const merged = [];
    const seen = new Set();
    local.concat(remote).forEach(it => {
        const key = (it.place_name || it.title || (it.coords || '').join(','));
        if (!seen.has(key)) { seen.add(key); merged.push(it); }
    });
    renderSuggestions(merged);
}, 220);

// wire input events for suggestions
addressInput.addEventListener('input', (e) => {
    debouncedSuggest(addressInput.value || '');
});

addressInput.addEventListener('keydown', (e) => {
    const rows = suggestions.querySelectorAll('.suggestion-row');
    if (!rows || rows.length === 0) return;
    if (e.key === 'ArrowDown') {
        e.preventDefault();
        const next = (suggestionSelected + 1) < rows.length ? suggestionSelected + 1 : 0;
        highlightSuggestion(next);
        rows[next].scrollIntoView({ block: 'nearest' });
    } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        const prev = (suggestionSelected - 1) >= 0 ? suggestionSelected - 1 : (rows.length - 1);
        highlightSuggestion(prev);
        rows[prev].scrollIntoView({ block: 'nearest' });
    } else if (e.key === 'Enter') {
        e.preventDefault();
        if (suggestionSelected >= 0 && suggestionSelected < suggestionItems.length) {
            selectSuggestion(suggestionItems[suggestionSelected]);
        } else if (suggestionItems.length === 1) {
            selectSuggestion(suggestionItems[0]);
        } else {
            // fallback to existing flow: try parse or geocode first result
            const txt = (addressInput.value || '').trim();
            (async () => {
                let coords = tryParseLngLat(txt);
                if (!coords) {
                    const remote = await forwardGeocode(txt);
                    coords = remote;
                }
                if (coords) {
                    map.flyTo({ center: coords, zoom: 18, essential: true });
                    clearAddressMarker();
                    addressMarker = new mapboxgl.Marker({ color: '#ff6a00' }).setLngLat(coords).addTo(map);
                } else {
                    alert('Location not found');
                }
            })();
        }
    } else if (e.key === 'Escape') {
        suggestions.classList.add('hidden');
    }
});


// helper: parse lng,lat input (lng first) or fallback to geocoding
function tryParseLngLat(text) {
    const parts = text.split(',').map(s => s.trim());
    if (parts.length === 2) {
        const lng = Number(parts[0]);
        const lat = Number(parts[1]);
        if (!Number.isNaN(lat) && !Number.isNaN(lng)) return [lng, lat];
    }
    return null;
}

async function forwardGeocode(query) {
    try {
        const token = mapboxgl.accessToken;
        const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(query)}.json?access_token=${token}&limit=1`;
        const res = await fetch(url);
        if (!res.ok) return null;
        const j = await res.json();
        if (j && j.features && j.features.length) {
            const f = j.features[0];
            return [f.center[0], f.center[1]];
        }
    } catch (e) { console.warn('Geocode failed', e); }
    return null;
}

addressGo.addEventListener('click', async () => {
    const txt = (addressInput.value || '').trim();
    if (!txt) return;
    // try parse coords first (expect lng,lat)
    let coords = tryParseLngLat(txt);
    if (!coords) coords = await forwardGeocode(txt);
    if (!coords) return alert('Location not found');
    // fly to location
    map.flyTo({ center: coords, zoom: 18, essential: true });
    clearAddressMarker();
    // add a temporary marker
    addressMarker = new mapboxgl.Marker({ color: '#ff6a00' }).setLngLat(coords).addTo(map);
});

// --- Image placement + persistence using IndexedDB ---
// Add hidden file input and wire Add image button
const addImageBtn = document.getElementById('add-image-btn');
const fileInput = document.createElement('input');
fileInput.type = 'file';
fileInput.accept = 'image/*';
fileInput.style.display = 'none';
document.body.appendChild(fileInput);

// IndexedDB helpers
const DB_NAME = 'map_images_db';
const DB_STORE = 'images_v1';
function openDb() {
    return new Promise((resolve, reject) => {
        const r = indexedDB.open(DB_NAME, 1);
        r.onupgradeneeded = () => {
            const db = r.result;
            if (!db.objectStoreNames.contains(DB_STORE)) db.createObjectStore(DB_STORE, { keyPath: 'id' });
        };
        r.onsuccess = () => resolve(r.result);
        r.onerror = () => reject(r.error);
    });
}

async function saveImageRecord(rec) {
    const db = await openDb();
    return new Promise((resolve, reject) => {
        const tx = db.transaction(DB_STORE, 'readwrite');
        const store = tx.objectStore(DB_STORE);
        const req = store.put(rec);
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
}

async function deleteImageRecord(id) {
    const db = await openDb();
    return new Promise((resolve, reject) => {
        const tx = db.transaction(DB_STORE, 'readwrite');
        const store = tx.objectStore(DB_STORE);
        const req = store.delete(id);
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
    });
}

async function listImageRecords() {
    const db = await openDb();
    return new Promise((resolve, reject) => {
        const tx = db.transaction(DB_STORE, 'readonly');
        const store = tx.objectStore(DB_STORE);
        const req = store.getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

// UI state for placing an image
let pendingImageDataUrl = null;

addImageBtn.addEventListener('click', () => { fileInput.click(); });

fileInput.addEventListener('change', async (ev) => {
    const f = ev.target.files && ev.target.files[0];
    if (!f) return;
    // read as data URL (suitable for small/medium images)
    const reader = new FileReader();
    reader.onload = () => {
        pendingImageDataUrl = reader.result;
        alert('Now click on the map to place the image');
    };
    reader.readAsDataURL(f);
    // reset input
    fileInput.value = '';
});

// place image on map when user clicks while pendingImageDataUrl set
map.on('click', async (e) => {
    if (!pendingImageDataUrl) return;
    const lngLat = [e.lngLat.lng, e.lngLat.lat];
    const id = 'img_' + Date.now();
    // create marker element (thumbnail)
    const img = document.createElement('img');
    img.src = pendingImageDataUrl;
    img.style.width = '120px';
    img.style.height = '80px';
    img.style.objectFit = 'cover';
    img.style.borderRadius = '6px';

    const marker = new mapboxgl.Marker({ element: img }).setLngLat(lngLat).addTo(map);

    // popup with full image and delete button
    const popupDiv = document.createElement('div');
    const full = document.createElement('img');
    full.src = pendingImageDataUrl;
    full.style.maxWidth = '300px';
    full.style.display = 'block';
    full.style.marginBottom = '6px';
    popupDiv.appendChild(full);
    const delBtn = document.createElement('button');
    delBtn.textContent = 'Remove image';
    delBtn.className = 'btn secondary';
    popupDiv.appendChild(delBtn);

    const popup = new mapboxgl.Popup().setDOMContent(popupDiv).setMaxWidth('320px');
    marker.setPopup(popup);

    // save to IndexedDB
    const rec = { id, dataUrl: pendingImageDataUrl, lng: lngLat[0], lat: lngLat[1], created: Date.now() };
    try { await saveImageRecord(rec); } catch (e) { console.warn('Failed saving image to IndexedDB', e); }

    // wire delete
    delBtn.addEventListener('click', async () => {
        try { await deleteImageRecord(id); marker.remove(); } catch (e) { console.warn(e); }
    });

    // clear pending
    pendingImageDataUrl = null;
});

// load saved images on startup
(async function restoreImages() {
    try {
        const rows = await listImageRecords();
        for (const r of rows) {
            try {
                const img = document.createElement('img');
                img.src = r.dataUrl;
                img.style.width = '120px'; img.style.height = '80px'; img.style.objectFit = 'cover'; img.style.borderRadius = '6px';
                const marker = new mapboxgl.Marker({ element: img }).setLngLat([r.lng, r.lat]).addTo(map);
                const popupDiv = document.createElement('div');
                const full = document.createElement('img'); full.src = r.dataUrl; full.style.maxWidth = '300px'; full.style.display = 'block'; full.style.marginBottom = '6px';
                popupDiv.appendChild(full);
                const delBtn = document.createElement('button'); delBtn.textContent = 'Remove image'; delBtn.className = 'btn secondary'; popupDiv.appendChild(delBtn);
                const popup = new mapboxgl.Popup().setDOMContent(popupDiv).setMaxWidth('320px');
                marker.setPopup(popup);
                delBtn.addEventListener('click', async () => { try { await deleteImageRecord(r.id); marker.remove(); } catch (e) { console.warn(e); } });
            } catch (e) { console.warn('Failed restoring image', e); }
        }
    } catch (e) { console.warn('Failed listing image records', e); }
})();

// capture map clicks for drawing (separate listener so we can short-circuit drawing behavior)
map.on('click', (e) => {
    // label placement takes priority if active
    if (placingLabel) {
    const coords = [e.lngLat.lng, e.lngLat.lat];
    const txt = (drawLabelInput && drawLabelInput.value) ? drawLabelInput.value.trim() : '';
    const feat = { type: 'Feature', geometry: { type: 'Point', coordinates: coords }, properties: { text: txt, color: selectedDrawColor, size: selectedTextSize } };
        drawnFeatures.push(feat);
        placingLabel = false;
        if (drawPlaceLabelBtn) drawPlaceLabelBtn.textContent = 'Place';
        // restore overlays
        setOverlayBlocking(true);
        try { saveDraws(); refreshDrawSource(); } catch (e) { console.warn('Failed to save label', e); }
        return;
    }
    if (!drawing) return;
    // add point to current draw (lng,lat)
    const coords = [e.lngLat.lng, e.lngLat.lat];
    if (!currentDraw) {
        // default to LineString if not explicitly set
        currentDraw = { type: 'Feature', geometry: { type: 'LineString', coordinates: [coords] }, properties: { color: selectedDrawColor } };
    } else {
        try {
            const g = currentDraw.geometry;
            if (g && g.type === 'Polygon') {
                // ensure ring exists
                if (!Array.isArray(g.coordinates) || !Array.isArray(g.coordinates[0])) g.coordinates = [[]];
                g.coordinates[0].push(coords);
            } else if (g && g.type === 'LineString') {
                if (!Array.isArray(g.coordinates)) g.coordinates = [];
                g.coordinates.push(coords);
            } else {
                // fallback
                if (!Array.isArray(currentDraw.geometry.coordinates)) currentDraw.geometry.coordinates = [];
                currentDraw.geometry.coordinates.push(coords);
            }
        } catch (e) { console.warn('Failed to append draw point', e); }
    }
    // update preview in drawnFeatures (not persisted until finish)
    // create a shallow preview: combine drawnFeatures + currentDraw
    try {
        const preview = drawnFeatures.concat(currentDraw ? [currentDraw] : []);
        ensureDrawSourceAndLayers();
        if (map.getSource && map.getSource('draw-source')) {
            map.getSource('draw-source').setData({ type: 'FeatureCollection', features: preview });
        }
    } catch (e) { console.warn('drawing click failed', e); }
});
</script>

</body>
</html>