<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Admin â€” Saved Map States</title>
  <style>
    body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial;margin:18px;background:#0f1724;color:#e6eef8}
    .card{background:#0b1220;padding:16px;border-radius:8px;box-shadow:0 8px 24px rgba(2,6,23,.6);max-width:1100px;margin:12px auto}
    table{width:100%;border-collapse:collapse;margin-top:12px}
    th,td{padding:8px 10px;border-bottom:1px solid rgba(255,255,255,0.04);text-align:left;font-size:13px}
    th{color:#9fb6c9;font-weight:600}
    .muted{color:#9fb6c9}
    .btn{background:#06b6d4;color:#071325;padding:6px 10px;border-radius:6px;border:none;cursor:pointer}
    .small{font-size:12px;padding:4px 8px}
    pre{background:#041018;padding:8px;border-radius:6px;overflow:auto;color:#dbeafe}
    .row{display:flex;gap:8px;align-items:center}
    input[type=text]{padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    .note{font-size:13px;color:#9fb6c9;margin-top:8px}
  </style>
</head>
<body>
  <div class="card">
    <h2>Admin: Saved Map States</h2>
    <div class="row">
      <button id="refresh" class="btn">Refresh list</button>
  <button id="pushLocal" class="btn small">Push local states</button>
      <label style="display:flex;align-items:center;gap:8px">
        <input id="importFile" type="file" accept="application/json" style="display:none" />
        <button id="importBtn" class="btn small">Import JSON</button>
      </label>
      <div style="flex:1"></div>
      <input id="manualId" placeholder="Enter state id (8 chars)" type="text" />
      <button id="fetchId" class="btn small">Fetch</button>
    </div>
    <div class="note">This page attempts to fetch a list of saved states from the server. If your backend does not expose a listing endpoint, paste a saved <code>state_id</code> above and click Fetch.</div>
    <div id="status" class="note"></div>

    <table id="results" style="display:none">
      <thead>
  <tr><th>Actions</th><th>ID</th><th>Name</th><th>Models</th><th>Draws</th><th>Center</th></tr>
      </thead>
      <tbody></tbody>
    </table>

    <div id="detail" style="margin-top:12px"></div>
  </div>

  <script>
    const BACKEND_STATE_ENDPOINT = 'https://locations-seven.vercel.app/api/state';

    const statusEl = document.getElementById('status');
    const resultsTbl = document.getElementById('results');
    const tbody = resultsTbl.querySelector('tbody');
    const detail = document.getElementById('detail');

    async function tryFetchList() {
      statusEl.textContent = 'Looking for listing endpoints...';
      const candidates = [BACKEND_STATE_ENDPOINT + '/list', BACKEND_STATE_ENDPOINT + '/all', BACKEND_STATE_ENDPOINT, BACKEND_STATE_ENDPOINT + '/states'];
      for (const url of candidates) {
        try {
          statusEl.textContent = 'Trying ' + url;
          const res = await fetch(url, { method: 'GET' });
          if (!res.ok) { continue; }
          const j = await res.json();
          // Accept either an array of ids, or array of full objects, or wrapper { states: [...] }
          if (Array.isArray(j)) return { type: 'array', data: j, url };
          if (Array.isArray(j.states)) return { type: 'array', data: j.states, url };
          if (Array.isArray(j.items)) return { type: 'array', data: j.items, url };
          // fallback: if object contains many keys, it might be a single state
          if (j && j.state && (j.id || j._id)) return { type: 'single', data: j, url };
        } catch (e) { /* ignore and try next */ }
      }
      return null;
    }

    async function fetchStateById(id) {
      try {
        const res = await fetch(BACKEND_STATE_ENDPOINT + '/' + encodeURIComponent(id));
        if (!res.ok) throw new Error('Not found');
        return await res.json();
      } catch (e) { throw e; }
    }

    function renderTable(entries) {
      tbody.innerHTML = '';
      if (!entries.length) {
        resultsTbl.style.display = 'none';
        statusEl.textContent = 'No entries found.';
        return;
      }
      resultsTbl.style.display = '';
      entries.forEach(e => {
        const tr = document.createElement('tr');
        const id = e.id || e._id || (e.key || '');
        const created = e.createdAt || e.created || '';
        const state = e.state || e;
        // determine a display name: prefer server-provided state.name or top-level e.name, otherwise local mapping
        let displayName = '';
        if (state && state.name) displayName = state.name;
        else if (e && e.name) displayName = e.name;
        else {
          try {
            const raw = localStorage.getItem('admin_known_state_names_v1');
            const map = raw ? JSON.parse(raw) : {};
            if (map && map[id]) displayName = map[id];
          } catch (err) { displayName = ''; }
        }
        const models = state && state.models ? (state.models.length || 0) : (e.modelsCount || 0);
        const draws = state && state.draws ? (state.draws.length || 0) : (e.drawsCount || 0);
        const center = state && state.mapCenter ? (Array.isArray(state.mapCenter) ? state.mapCenter.join(',') : JSON.stringify(state.mapCenter)) : '';

  tr.innerHTML = `<td><button class="btn small" data-id="${id}">Open</button> <button class="btn small" data-id="${id}" data-action="view">View JSON</button> <button class="btn small" data-id="${id}" data-action="delete" style="background:#ef4444;color:#fff">Delete</button></td><td><code>${id}</code></td><td>${escapeHtml(displayName)}</td><td>${models}</td><td>${draws}</td><td class="muted">${center}</td>`;
        tbody.appendChild(tr);
      });
      // tiny helper to escape HTML when injecting displayName
      function escapeHtml(str) {
        if (!str) return '';
        return String(str).replace(/[&<>"']/g, function(m) { return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[m]; });
      }
      // wire buttons
      tbody.querySelectorAll('button').forEach(b => b.addEventListener('click', async (ev) => {
        const id = b.dataset.id;
        const action = b.dataset.action;
        if (!id) return;
        if (action === 'view') {
          try {
            const j = await fetchStateById(id);
            detail.innerHTML = `<h3>State ${id}</h3><pre>${JSON.stringify(j, null, 2)}</pre><div style="margin-top:8px"><button id="detail-delete" class="btn" style="background:#ef4444;color:#fff">Delete this state</button></div>`;
            // wire delete in detail
            document.getElementById('detail-delete').addEventListener('click', async () => {
              if (!confirm('Delete state ' + id + '? This cannot be undone.')) return;
              await deleteState(id);
            });
          } catch (e) { detail.innerHTML = '<div class="note">Failed to fetch: '+ e.message +'</div>'; }
          return;
        }
        if (action === 'delete') {
          if (!confirm('Delete state ' + id + '? This cannot be undone.')) return;
          await deleteState(id);
          return;
        }
  // Open in new tab using the main app page with state_id query param
  // Compute the base path (strip the last path segment) and open the main map with the state_id
  const base = location.pathname.replace(/[^/]*$/, '');
  const target = location.origin + base + 'index.html?state_id=' + encodeURIComponent(id);
  window.open(target, '_blank');
      }));
    }

    async function refresh() {
      detail.innerHTML = '';
      statusEl.textContent = 'Refreshing...';
      const found = await tryFetchList();
      if (!found) {
        statusEl.textContent = 'No listing endpoint found. Trying locally saved ids...';
        // look for locally-saved ids added by the Save button
        try {
          const raw = localStorage.getItem('admin_known_state_ids_v1');
          const list = raw ? JSON.parse(raw) : [];
          if (list && list.length) {
            const rows = [];
            for (const id of list) {
              try {
                const res = await fetchStateById(id);
                rows.push({ id, state: res && res.state ? res.state : res });
              } catch (e) { rows.push({ id, error: true }); }
            }
            renderTable(rows);
            statusEl.textContent = 'Loaded ' + rows.length + ' locally-saved entries.';
            return;
          }
        } catch (e) { /* ignore */ }
        statusEl.textContent = 'No listing endpoint found. Use manual fetch by ID.';
        return;
      }
      statusEl.textContent = 'Parsing list from ' + found.url;
      let items = found.data;
      // If items are simple ids, fetch each
      if (items.length && typeof items[0] === 'string') {
        const rows = [];
        statusEl.textContent = 'Fetching ' + items.length + ' states...';
        await Promise.all(items.map(async (id) => {
          try {
            const res = await fetchStateById(id);
            const obj = res && res.state ? Object.assign({ id }, res.state) : Object.assign({ id }, res);
            rows.push({ id, state: obj });
          } catch (e) { rows.push({ id, error: true }); }
        }));
        renderTable(rows);
        statusEl.textContent = 'Loaded ' + rows.length + ' entries.';
        return;
      }
      // If items are objects that may include state or metrics
      const normalized = items.map(it => {
        if (it && (it.state || it.models || it.draws)) return it;
        // if wrapper like { id, state }
        if (it && it.id && it.state) return Object.assign({ id: it.id }, it);
        return it;
      });
      renderTable(normalized);
      statusEl.textContent = 'Loaded ' + normalized.length + ' entries.';
    }

    // helper to remove id from localStorage known list
    function removeLocalKnownId(id) {
      try {
        const key = 'admin_known_state_ids_v1';
        const raw = localStorage.getItem(key);
        if (!raw) return;
        let arr = [];
        try { arr = JSON.parse(raw); } catch (e) { arr = []; }
        arr = arr.filter(x => x !== id);
        localStorage.setItem(key, JSON.stringify(arr));
      } catch (e) { /* ignore */ }
    }

    async function deleteState(id) {
      try {
        statusEl.textContent = 'Deleting ' + id + '...';
        // helper to centralize success handling
        const handleSuccess = async () => {
          removeLocalKnownId(id);
          statusEl.textContent = 'Deleted ' + id;
          await refresh();
          detail.innerHTML = '';
        };

        const attempts = [];

        // small helper to perform a fetch and record the outcome
        async function tryFetch(label, url, opts) {
          let out = { label, url, opts: Object.assign({}, opts || {}) };
          try {
            const r = await fetch(url, opts || {});
            out.status = r.status;
            try { out.text = await r.text(); } catch (e) { out.text = '[no-body]'; }
            out.ok = r.ok;
            attempts.push(out);
            return out;
          } catch (err) {
            out.error = String(err && err.message || err);
            attempts.push(out);
            return out;
          }
        }

        const idPath = '/' + encodeURIComponent(id);
        const base = BACKEND_STATE_ENDPOINT;

        // 1) DELETE as-is
        const a1 = await tryFetch('DELETE', base + idPath, { method: 'DELETE' });
        if (a1.ok) { await handleSuccess(); return; }

        // 2) DELETE with JSON content-type and empty body (some servers expect a body)
        const a2 = await tryFetch('DELETE-with-body', base + idPath, { method: 'DELETE', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({}) });
        if (a2.ok) { await handleSuccess(); return; }

        // 3) POST with method override header
        const a3 = await tryFetch('POST-x-http-method-override', base + idPath, { method: 'POST', headers: { 'X-HTTP-Method-Override': 'DELETE', 'Content-Type': 'application/json' }, body: JSON.stringify({}) });
        if (a3.ok) { await handleSuccess(); return; }

        // 4) POST to /delete with id in body
        const a4 = await tryFetch('POST-/delete', base + '/delete', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ id }) });
        if (a4.ok) { await handleSuccess(); return; }

        // 5) POST to /:id/delete
        const a5 = await tryFetch('POST-/:id/delete', base + idPath + '/delete', { method: 'POST' });
        if (a5.ok) { await handleSuccess(); return; }

        // 6) try /remove variants
        const a6 = await tryFetch('POST-/remove', base + '/remove', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ id }) });
        if (a6.ok) { await handleSuccess(); return; }
        const a7 = await tryFetch('POST-/:id/remove', base + idPath + '/remove', { method: 'POST' });
        if (a7.ok) { await handleSuccess(); return; }

        // nothing succeeded â€” build a full diagnostic message
        const diag = attempts.map(a => ({ label: a.label, url: a.url, status: a.status || 'no-response', ok: !!a.ok, text: a.text || a.error || '' }));
        // Offer a local-only removal fallback if the server refuses
        const diagStr = JSON.stringify(diag, null, 2);
        const msg = `Remote delete failed. Attempts:\n${diagStr}\n\nYou can remove the id from this browser (local-only) so it won't show in the admin list. Proceed with local-only removal?`;
        statusEl.textContent = 'Delete failed: server refused delete';
        // show detailed diagnostic in the detail pane using a safe textContent pre element
        detail.innerHTML = '<h3>Delete diagnostics</h3>';
        const pre = document.createElement('pre');
        pre.textContent = diagStr;
        detail.appendChild(pre);
        if (confirm(msg)) {
          removeLocalKnownId(id);
          statusEl.textContent = 'Locally removed ' + id;
          await refresh();
          detail.innerHTML = '';
          return;
        }
        throw new Error('Delete failed: remote server refused delete. See diagnostics.');
      } catch (e) {
        statusEl.textContent = 'Delete failed: ' + (e && e.message);
        alert('Delete failed: ' + (e && e.message));
      }
    }

    document.getElementById('refresh').addEventListener('click', refresh);
    document.getElementById('pushLocal').addEventListener('click', async () => {
      const localKey = 'admin_local_state_payloads_v1';
      try {
        const raw = localStorage.getItem(localKey);
        const arr = raw ? JSON.parse(raw) : [];
        if (!arr || !arr.length) { statusEl.textContent = 'No local payloads found'; return; }
        statusEl.textContent = 'Pushing ' + arr.length + ' local payload(s)...';
        const results = [];
        for (let item of arr) {
          try {
            const payload = { state: item.state, name: item.name || '' };
            const res = await fetch(BACKEND_STATE_ENDPOINT, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!res.ok) { results.push({ ok: false, error: 'HTTP ' + res.status, item }); continue; }
            const j = await res.json();
            const id = j && j.id;
            if (id) {
              // store id/name in local known lists
              try { const key = 'admin_known_state_ids_v1'; const rawk = localStorage.getItem(key); let arrk = rawk ? JSON.parse(rawk) : []; if (!arrk.includes(id)) { arrk.unshift(id); localStorage.setItem(key, JSON.stringify(arrk)); } } catch (e) {}
              try { const namesKey = 'admin_known_state_names_v1'; const rawNames = localStorage.getItem(namesKey); let map = rawNames ? JSON.parse(rawNames) : {}; map[id] = item.name || ''; localStorage.setItem(namesKey, JSON.stringify(map)); } catch (e) {}
              results.push({ ok: true, id, item });
            } else {
              results.push({ ok: false, error: 'no id returned', item });
            }
          } catch (e) { results.push({ ok: false, error: e && e.message, item }); }
        }
        detail.innerHTML = '<h3>Push results</h3><pre>' + JSON.stringify(results, null, 2) + '</pre>';
        statusEl.textContent = 'Push finished';
        // optionally refresh list now
        await refresh();
      } catch (e) { statusEl.textContent = 'Push failed: ' + (e && e.message); alert('Push failed: ' + (e && e.message)); }
    });
    document.getElementById('fetchId').addEventListener('click', async () => {
      const id = document.getElementById('manualId').value.trim();
      if (!id) { statusEl.textContent = 'Enter an id first'; return; }
      statusEl.textContent = 'Fetching ' + id + '...';
      try {
        const res = await fetchStateById(id);
        detail.innerHTML = `<h3>State ${id}</h3><pre>${JSON.stringify(res, null, 2)}</pre>`;
        statusEl.textContent = 'Fetched ' + id;
      } catch (e) { statusEl.textContent = 'Failed to fetch: ' + e.message; detail.innerHTML = ''; }
    });

    // Import JSON file (single state or array of states) and POST to backend
    const importFile = document.getElementById('importFile');
    const importBtn = document.getElementById('importBtn');
    importBtn.addEventListener('click', () => importFile.click());
    importFile.addEventListener('change', async (ev) => {
      const f = ev.target.files && ev.target.files[0];
      if (!f) return;
      try {
        statusEl.textContent = 'Reading file...';
        const txt = await f.text();
        const parsed = JSON.parse(txt);
        const items = Array.isArray(parsed) ? parsed : [parsed];
        statusEl.textContent = 'Importing ' + items.length + ' states...';
        const results = [];
        for (const s of items) {
          try {
            const payload = { state: s };
            const res = await fetch(BACKEND_STATE_ENDPOINT, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!res.ok) { results.push({ ok: false, error: 'HTTP ' + res.status }); continue; }
            const j = await res.json();
            const id = j && j.id;
            if (id) {
              // save locally for admin fallback
              try { const key = 'admin_known_state_ids_v1'; const raw = localStorage.getItem(key); let arr = raw ? JSON.parse(raw) : []; if (!arr.includes(id)) { arr.unshift(id); localStorage.setItem(key, JSON.stringify(arr)); } } catch (e) {}
              results.push({ ok: true, id });
            } else {
              results.push({ ok: false, error: 'No id returned' });
            }
          } catch (e) { results.push({ ok: false, error: e && e.message }); }
        }
        detail.innerHTML = '<h3>Import results</h3><pre>' + JSON.stringify(results, null, 2) + '</pre>';
        statusEl.textContent = 'Import finished';
        await refresh();
      } catch (e) { statusEl.textContent = 'Import failed: ' + (e && e.message); alert('Import failed: ' + (e && e.message)); }
      importFile.value = '';
    });

    // auto-refresh on load
    refresh();
  </script>
</body>
</html>
